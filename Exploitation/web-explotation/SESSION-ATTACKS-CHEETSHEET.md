# <a id="top-of-page"></a> Session Attacks

### Links

- [Session Hijacking](#sess-hijack)
- [Session Fixation](#sess-fix)
- [Stealing Session IDs without user interaction](#sess-steal)
- [XSS](#xss)
- [CSRF](#csrf)
- [Weak CSRF Tokens](#csrf-weak)
- [Additional CSRF Bypasses](#csrf-bypass)
- [Open Redirect](#open-redir)

## <a id="sess-hijack"></a> -Session Hijacking-

In session hijacking attacks, the attacker takes advantage of insecure session identifiers, finds a way to obtain them, and uses them to authenticate to the server and impersonate the victim.

An attacker can obtain a victim's session identifier using several methods, with the most common being:

- Passive Traffic Sniffing
- Cross-Site Scripting (XSS)
- Browser history or log-diving
- Read access to a database containing session information

As mentioned in the previous section, if a session identifier's security level is low, an attacker may also be able to brute force it or even predict it.

[Back to top](#top-of-page)

</br>

## <a id="sess-fix"></a> -Session Fixation-

Session Fixation occurs when an attacker can fixate a (valid) session identifier. The attacker will then have to trick the victim into logging into the application using the aforementioned session identifier.

**_Stage 1:_** Attacker obtains a valid session identifier

This stage may or may not require the attacker to log into the application to obtain a session ID.

**_Stage 2:_** Attacker manages to fixate a valid session identifier

The pattern to look for to ID a fixation vulnerability are below:

- The assigned session identifier pre-login remains the same post-login **and**
- Session identifiers (such as cookies) are being accepted from URL Query Strings or Post Data and propagated to the application

**_Stage 3:_** Attacker tricks the victim into establishing a session using the abovementioned session identifier

All the attacker has to do is craft a URL and lure the victim into visiting it. If the victim does so, the web application will then assign this session identifier to the victim.

The attacker can then proceed to a session hijacking attack since the session identifier is already known.

| **URL**                                                                            | **Description**                                          |
| ---------------------------------------------------------------------------------- | -------------------------------------------------------- |
| `http://oredirect.htb.net/?redirect_uri=/complete.html&token=<RANDOM TOKEN VALUE>` | Example of a URL that could be used for Session Fixation |

## <a id="sess-steal"></a> -Stealing Session IDs without User Interaction-

### --Traffic Sniffing--

When attempting to use Traffic sniffing to find session IDs, there are two requirements for this to work.

- The attacker must be positioned on the same local network as the victim
- Unencrypted HTTP traffic

Tools like Wireshark can be used to perform the sniffing, with filtration taking place one enough traffic has been captured.

### --Post-Exploitation (web Server)--

During the post-exploitation phase, session identifiers and session data can be retrieved from either a web server's disk or memory.

Below are common locations where Session IDs are stored in common Web Server frameworks:

- PHP
  - /var/lib/php/sessions
- Java
  - SESSIONS.ser file (more info [here](http://tomcat.apache.org/tomcat-6.0-doc/config/manager.html))
- .NET
  - The application worker process (aspnet_wp.exe) - This is the case in the InProc Session mode
  - StateServer (A Windows Service residing on IIS or a separate server) - This is the case in the OutProc Session mode
  - An SQL Server
- Database Access
  - Always check for a 'sessions' table or something similar

[Back to top](#top-of-page)

</br>

## <a id="xss"></a> -XSS-

[LINK]() to the XSS cheetsheet.

[Back to top](#top-of-page)

</br>

## <a id="csrf"></a> -CSRF-

Cross-Site Request Forgery (CSRF or XSRF) is an attack that forces an end-user to execute inadvertent actions on a web application in which they are currently authenticated.

There are two considerations for a CSRF attack to work:

- A web app is vulnerable to CSRF when:
  - All the parameters required for the targeted request can be determined or guessed by the attacker
  - The application's session management is solely based on HTTP cookies, which are automatically included in browser requests
- A successful exploitation of CSRF requires:
  - A crafted malicious web page that will issue a valid (cross-site) request impersonating the victim
  - The victim to be logged into the application at the time when the malicious cross-site request is issued

Look up examples of GET/POST CSRF attacks.

[Back to top](#top-of-page)

</br>

## <a id="csrf-weak"></a> -Weak CSRF Tokens-

Often, web applications do not employ very secure or robust token generation algorithms. An example is an application that generates CSRF tokens as follows (pseudocode): md5(username). An attacker should register an account (assuming possible) and then check the MD5 value of their username to see if it matches with CSRF token.

Other possibilities could be sha1(username), md5(current date + username).

[Back to top](#top-of-page)

</br>

## <a id="csrf-bypass"></a> -Additional CSRF Bypasses-

### --NULL Value--

Try making the CSRF token a null value (empty), for example:

CSRF-Token:

This may work because sometimes, the check is only looking for the header, and it does not validate the token value. In such cases, we can craft our cross-site requests using a null CSRF token, as long as the header is provided in the request.

### --Random CSRF Token--

Setting the CSRF token value to the same length as the original CSRF token but with a different/random value may also bypass some anti-CSRF protection that validates if the token has a value and the length of that value. For example, if the CSRF-Token were 32-bytes long, re-create a 32-byte token.

Real:

CSRF-Token: 9cfffd9e8e78bd68975e295d1b3d3331

Fake:

CSRF-Token: 9cfffl3dj3837dfkj3j387fjcxmfjfd3

### --Use Another Session's CSRF Token--

Another anti-CSRF protection bypass is using the same CSRF token across accounts. This may work in applications that do not validate if the CSRF token is tied to a specific account or not and only check if the token is algorithmically correct.

Create two accounts and log into the first account. Generate a request and capture the CSRF token. Copy the token's value, for example, CSRF-Token=9cfffd9e8e78bd68975e295d1b3d3331.

Log into the second account and change the value of CSRF-Token to 9cfffd9e8e78bd68975e295d1b3d3331 while issuing the same (or a different) request.

### --Request Method Tampering--

Try changing the request method. From POST to GET and vice versa. Unexpected requests may be served without the need for a CSRF token.

### --Delete the CSRF token param/send blank--

Not sending a token works fairly often because of the following common application logic mistake. Applications sometimes only check the token's validity if the token exists or if the token parameter is not blank.

### --Session Fixation > CSRF--

Sometimes, sites use something called a double-submit cookie as a defense against CSRF. This means that the sent request will contain the same random token both as a cookie and as a request parameter, and the server checks if the two values are equal. If the values are equal, the request is considered legitimate.

If the double-submit cookie is used as the defense mechanism, the application is probably not keeping the valid token on the server-side. It has no way of knowing if any token it receives is legitimate and merely checks that the token in the cookie and the token in the request body are the same.

If this is the case and a session fixation vulnerability exists, an attacker could perform a successful CSRF attack as follows:

Steps:

Session fixation
Execute CSRF with the following request:

```
POST /change_password
Cookie: CSRF-Token=fixed_token;
POST body:
new_password=pwned&CSRF-Token=fixed_token
```

### --Remove Referrer Header--

If an application is using the referrer header as an anti-CSRF mechanism, the attacker can try removing the referrer header. The following meta tag in the attacker page hosting your CSRF script, will potentially bypass this check.

<meta name="referrer" content="no-referrer"

### --Bypass the Regex--

Sometimes the Referrer has a whitelist regex or a regex that allows one specific domain.

Suppose that the Referrer Header is checking for google.com. Something like www.google.com.pwned.m3 may bypass the regex. If it uses its own domain (target.com) as a whitelist, try using the target domain as follows www.target.com.pwned.m3.

Other examples:

www.target.com?www.pwned.m3 or www.pwned.m3/www.target.com

[Back to top](#top-of-page)

</br>

## <a id="open-redir"></a> -Open Redirect-

An Open Redirect vulnerability occurs when an attacker can redirect a victim to an attacker-controlled site by abusing a legitimate application's redirection functionality. In such cases, all the attacker has to do is specify a website under their control in a redirection URL of a legitimate website and pass this URL to the victim. This would be useful to send the victim to an attacker controlled site from a site that the victim trusts.

Check for the follow params to find this vul:

- ?url=
- ?link=
- ?redirect=
- ?redirecturl=
- ?redirect_uri=
- ?return=
- ?return_to=
- ?returnurl=
- ?go=
- ?goto=
- ?exit=
- ?exitpage=
- ?fromurl=
- ?fromuri=
- ?redirect_to=
- ?next=
- ?newurl=
- ?redir=

[Back to top](#top-of-page)
session-attacks.md.txt
Displaying session-attacks.md.txt.
